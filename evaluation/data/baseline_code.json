{"88": "\nimpl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n\n        while i < m && j < n {\n            if nums1[i] <= nums2[j] {\n                nums1[k] = nums1[i];\n                i += 1;\n            } else {\n                nums1[k] = nums2[j];\n                j += 1;\n            }\n            k += 1;\n        }\n\n        while i < m {\n            nums1[k] = nums1[i];\n            i += 1;\n            k += 1;\n        }\n\n        while j < n {\n            nums1[k] = nums2[j];\n            j += 1;\n            k += 1;\n        }\n    }\n}\n", "27": "\nimpl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n        let mut k = 0;\n        for i in 0..nums.len() {\n            if nums[i] != val {\n                nums[k] = nums[i];\n                k += 1;\n            }\n        }\n        k\n    }\n}\n", "26": "\nimpl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let mut unique_elements = HashSet::new();\n        let mut k = 0;\n\n        for num in nums {\n            if !unique_elements.contains(num) {\n                unique_elements.insert(num);\n                nums[k] = num;\n                k += 1;\n            }\n        }\n\n        k\n    }\n}\n", "80": "\nimpl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let mut i = 0;\n        let mut j = 1;\n        let mut count = 1;\n\n        while j < nums.len() {\n            if nums[i] == nums[j] {\n                count += 1;\n                if count > 2 {\n                    nums.remove(j);\n                } else {\n                    j += 1;\n                }\n            } else {\n                i += 1;\n                nums[i] = nums[j];\n                j += 1;\n            }\n        }\n\n        i + 1\n    }\n}\n", "169": "\nimpl Solution {\n    pub fn majority_element(nums: Vec<i32>) -> i32 {\n        let mut count = 0;\n        let mut candidate = 0;\n\n        for num in nums {\n            if count == 0 {\n                candidate = num;\n            }\n            count += if num == candidate { 1 } else { -1 };\n        }\n\n        candidate\n    }\n}\n", "189": "\nimpl Solution {\n    pub fn rotate(nums: &mut Vec<i32>, k: i32) {\n        let n = nums.len();\n        let k = k as usize % n;\n        nums.rotate_left(k);\n    }\n}\n", "121": "\nimpl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut min_price = i32::MAX;\n        let mut max_profit = 0;\n\n        for price in prices {\n            if price < min_price {\n                min_price = price;\n            } else if price - min_price > max_profit {\n                max_profit = price - min_price;\n            }\n        }\n\n        max_profit\n    }\n}\n", "122": "\nimpl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut min_price = i32::MAX;\n        let mut max_profit = 0;\n\n        for price in prices {\n            if price < min_price {\n                min_price = price;\n            } else if price - min_price > max_profit {\n                max_profit = price - min_price;\n            }\n        }\n\n        max_profit\n    }\n}\n", "55": "\nimpl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        let mut current_index = 0;\n        let mut max_reachable_index = 0;\n\n        while current_index < nums.len() {\n            if current_index > max_reachable_index {\n                return false;\n            }\n\n            let jump_length = nums[current_index] as usize;\n            max_reachable_index = std::cmp::max(max_reachable_index, current_index + jump_length);\n            current_index += 1;\n        }\n\n        true\n    }\n}\n", "45": "\nimpl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        // Initialize the minimum number of jumps to reach the last index\n        let mut min_jumps = 0;\n\n        // Initialize the maximum number of jumps that can be made from each index\n        let mut max_jumps = vec![0; nums.len()];\n\n        // Initialize the current maximum jump distance\n        let mut current_max_jump = 0;\n\n        // Loop through the array from the end to the start\n        for i in (0..nums.len()).rev() {\n            // If the current index is the last index, return the minimum number of jumps\n            if i == nums.len() - 1 {\n                return min_jumps;\n            }\n\n            // If the current index is not the last index, update the maximum jump distance\n            if i < nums.len() - 1 {\n                current_max_jump = nums[i].max(current_max_jump);\n            }\n\n            // If the current index is not the last index and the maximum jump distance is 0, return -1\n            if i < nums.len() - 1 && current_max_jump == 0 {\n                return -1;\n            }\n\n            // Update the minimum number of jumps\n            min_jumps += 1;\n\n            // Update the maximum jump distance for the next iteration\n            max_jumps[i] = current_max_jump;\n        }\n\n        // Return the minimum number of jumps\n        min_jumps\n    }\n}\n", "274": "\nimpl Solution {\n    pub fn h_index(citations: Vec<i32>) -> i32 {\n        let mut citation_counts = HashMap::new();\n        for citation in citations {\n            *citation_counts.entry(citation).or_insert(0) += 1;\n        }\n        let mut h_index = 0;\n        for (citation, count) in citation_counts {\n            if count >= citation {\n                h_index = citation;\n                break;\n            }\n        }\n        h_index\n    }\n}\n", "380": "\nstruct RandomizedSet {\n    set: HashSet<i32>,\n    rng: StdRng,\n}\n\nimpl RandomizedSet {\n    fn new() -> Self {\n        RandomizedSet {\n            set: HashSet::new(),\n            rng: StdRng::from_seed(rand::thread_rng().gen()),\n        }\n    }\n\n    fn insert(&mut self, val: i32) -> bool {\n        if self.set.contains(&val) {\n            false\n        } else {\n            self.set.insert(val);\n            true\n        }\n    }\n\n    fn remove(&mut self, val: i32) -> bool {\n        if self.set.remove(&val) {\n            true\n        } else {\n            false\n        }\n    }\n\n    fn get_random(&self) -> i32 {\n        let mut rng = self.rng.clone();\n        let mut iter = self.set.iter();\n        let mut i = 0;\n        while let Some(val) = iter.next() {\n            if rng.gen_bool(0.5) {\n                return *val;\n            }\n            i += 1;\n        }\n        panic!(\"No elements in the set\");\n    }\n}\n", "238": "\nimpl Solution {\n    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        let mut products = vec![1; nums.len()];\n        let mut product = 1;\n        for i in 0..nums.len() {\n            products[i] = product;\n            product *= nums[i];\n        }\n        product = 1;\n        for i in (0..nums.len()).rev() {\n            products[i] *= product;\n            product *= nums[i];\n        }\n        products\n    }\n}\n", "134": "\nimpl Solution {\n    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\n        let mut total_gas = 0;\n        let mut total_cost = 0;\n        let mut start_index = 0;\n\n        for i in 0..gas.len() {\n            total_gas += gas[i];\n            total_cost += cost[i];\n\n            if total_gas < total_cost {\n                return -1;\n            }\n\n            if total_gas == total_cost {\n                start_index = i;\n            }\n        }\n\n        start_index\n    }\n}\n", "135": "\nimpl Solution {\n    pub fn candy(ratings: Vec<i32>) -> i32 {\n        let mut candies = vec![1; ratings.len()];\n        let mut max_candy = 1;\n\n        for i in 1..ratings.len() {\n            if ratings[i] > ratings[i - 1] {\n                candies[i] = max_candy + 1;\n                max_candy = max_candy + 1;\n            } else {\n                candies[i] = max_candy;\n            }\n        }\n\n        let mut total_candies = 0;\n        for candy in candies {\n            total_candies += candy;\n        }\n\n        total_candies\n    }\n}\n", "42": "\nimpl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        let mut left = 0;\n        let mut right = height.len() - 1;\n        let mut left_max = 0;\n        let mut right_max = 0;\n        let mut water = 0;\n\n        while left < right {\n            if height[left] < height[right] {\n                if height[left] > left_max {\n                    left_max = height[left];\n                } else {\n                    water += left_max - height[left];\n                }\n                left += 1;\n            } else {\n                if height[right] > right_max {\n                    right_max = height[right];\n                } else {\n                    water += right_max - height[right];\n                }\n                right -= 1;\n            }\n        }\n\n        water\n    }\n}\n", "13": "\nimpl Solution {\n    pub fn roman_to_int(s: String) -> i32 {\n        let mut result = 0;\n        let mut i = 0;\n        while i < s.len() {\n            let c = s.chars().nth(i).unwrap();\n            match c {\n                'I' => result += 1,\n                'V' => result += 5,\n                'X' => result += 10,\n                'L' => result += 50,\n                'C' => result += 100,\n                'D' => result += 500,\n                'M' => result += 1000,\n                _ => panic!(\"Invalid character in roman numeral: {}\", c),\n            }\n            i += 1;\n        }\n        result\n    }\n}\n", "12": "\nimpl Solution {\n    pub fn int_to_roman(num: i32) -> String {\n        let mut result = String::new();\n        let mut num = num;\n\n        while num >= 1000 {\n            result.push('M');\n            num -= 1000;\n        }\n\n        while num >= 500 {\n            result.push('D');\n            num -= 500;\n        }\n\n        while num >= 100 {\n            result.push('C');\n            num -= 100;\n        }\n\n        while num >= 50 {\n            result.push('L');\n            num -= 50;\n        }\n\n        while num >= 10 {\n            result.push('X');\n            num -= 10;\n        }\n\n        while num >= 5 {\n            result.push('V');\n            num -= 5;\n        }\n\n        while num >= 1 {\n            result.push('I');\n            num -= 1;\n        }\n\n        result\n    }\n}\n", "58": "\nimpl Solution {\n    pub fn length_of_last_word(s: String) -> i32 {\n        let mut words = s.split_whitespace();\n        let last_word = words.next_back().unwrap();\n        last_word.len() as i32\n    }\n}\n", "14": "\nfn longest_common_prefix(strs: Vec<String>) -> String {\n    if strs.is_empty() {\n        return \"\".to_string();\n    }\n\n    let mut prefix = strs[0].clone();\n    for i in 1..strs.len() {\n        while !strs[i].starts_with(&prefix) {\n            prefix.pop();\n        }\n    }\n\n    prefix\n}\n", "151": "\nimpl Solution {\n    pub fn reverse_words(s: String) -> String {\n        let mut words = s.split_whitespace();\n        let mut reversed_words = Vec::new();\n\n        while let Some(word) = words.next() {\n            reversed_words.push(word.to_string());\n        }\n\n        reversed_words.reverse();\n\n        reversed_words.join(\" \")\n    }\n}\n", "6": "\nimpl Solution {\n    pub fn convert(s: String, num_rows: i32) -> String {\n        let mut result = String::new();\n        let mut row = 0;\n        let mut col = 0;\n        let mut direction = 1;\n\n        for c in s.chars() {\n            result.push(c);\n            if row == 0 || row == num_rows - 1 {\n                direction = -direction;\n            }\n            row += direction;\n            col += 1;\n        }\n\n        result\n    }\n}\n", "28": "\nimpl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        let haystack_chars = haystack.chars();\n        let needle_chars = needle.chars();\n        let mut i = 0;\n        let mut j = 0;\n        while i < haystack_chars.len() && j < needle_chars.len() {\n            if haystack_chars[i] == needle_chars[j] {\n                j += 1;\n            } else {\n                i += 1;\n                j = 0;\n            }\n        }\n        if j == needle_chars.len() {\n            return i as i32;\n        } else {\n            return -1;\n        }\n    }\n}\n", "68": "\nimpl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        let mut result = Vec::new();\n        let mut current_line = String::new();\n        let mut current_width = 0;\n\n        for word in words {\n            if current_width + word.len() > max_width {\n                result.push(current_line);\n                current_line = String::new();\n                current_width = 0;\n            }\n\n            current_line.push_str(word);\n            current_width += word.len();\n\n            if !current_line.is_empty() {\n                current_line.push(' ');\n                current_width += 1;\n            }\n        }\n\n        if !current_line.is_empty() {\n            result.push(current_line);\n        }\n\n        result\n    }\n}\n", "125": "\nimpl Solution {\n    pub fn is_palindrome(s: String) -> bool {\n        let mut s = s.to_lowercase();\n        s.retain(|c| c.is_alphanumeric());\n        s == s.chars().rev().collect::<String>()\n    }\n}\n", "392": "\nimpl Solution {\n    pub fn is_subsequence(s: String, t: String) -> bool {\n        let s_chars = s.chars();\n        let t_chars = t.chars();\n\n        let mut window_start = 0;\n        for (i, t_char) in t_chars.enumerate() {\n            if s_chars.nth(window_start) == Some(t_char) {\n                window_start += 1;\n            }\n            if window_start == s.len() {\n                return true;\n            }\n        }\n\n        false\n    }\n}\n", "167": "\nimpl Solution {\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut left = 0;\n        let mut right = numbers.len() - 1;\n\n        while left < right {\n            let sum = numbers[left] + numbers[right];\n            if sum == target {\n                return vec![left + 1, right + 1];\n            } else if sum < target {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n\n        vec![]\n    }\n}\n", "11": "\nimpl Solution {\n    pub fn max_area(height: Vec<i32>) -> i32 {\n        let mut max_area = 0;\n        let mut left = 0;\n        let mut right = height.len() - 1;\n\n        while left < right {\n            let area = (right - left) as i32 * (height[left].min(height[right]));\n            max_area = max_area.max(area);\n\n            if height[left] < height[right] {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n\n        max_area\n    }\n}\n", "15": "\nimpl Solution {\n    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        for i in 0..nums.len() {\n            for j in i+1..nums.len() {\n                for k in j+1..nums.len() {\n                    if nums[i] + nums[j] + nums[k] == 0 {\n                        result.push(vec![nums[i], nums[j], nums[k]]);\n                    }\n                }\n            }\n        }\n        result\n    }\n}\n", "209": "\nimpl Solution {\n    pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {\n        let mut sum = 0;\n        let mut min_len = 0;\n        let mut start = 0;\n        let mut end = 0;\n\n        for i in 0..nums.len() {\n            sum += nums[i];\n            while sum >= target {\n                min_len = std::cmp::min(min_len, i - start + 1);\n                sum -= nums[start];\n                start += 1;\n            }\n        }\n\n        if min_len == 0 {\n            0\n        } else {\n            min_len\n        }\n    }\n}\n", "3": "\nimpl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        let mut longest_substring = 0;\n        let mut start = 0;\n        let mut end = 0;\n\n        while end < s.len() {\n            let current_char = s[end];\n            if !s[start..end].contains(current_char) {\n                longest_substring = std::cmp::max(longest_substring, end - start + 1);\n                start = end;\n            }\n            end += 1;\n        }\n\n        longest_substring\n    }\n}\n", "30": "\nimpl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut i = 0;\n        while i < s.len() {\n            let mut j = 0;\n            while j < words.len() {\n                let word = words[j];\n                let mut k = i;\n                while k < s.len() && s[k] == word[0] {\n                    k += 1;\n                }\n                if k - i == word.len() {\n                    i = k;\n                    j += 1;\n                } else {\n                    break;\n                }\n            }\n            if j == words.len() {\n                result.push(i as i32);\n            }\n            i += 1;\n        }\n        result\n    }\n}\n", "76": "\nimpl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        let s = s.as_bytes();\n        let t = t.as_bytes();\n        let mut window = Vec::new();\n        let mut min_window = Vec::new();\n        let mut i = 0;\n        let mut j = 0;\n        let mut count = 0;\n\n        while i < s.len() {\n            if s[i] == t[j] {\n                window.push(s[i]);\n                count += 1;\n                j += 1;\n                if j == t.len() {\n                    min_window = window;\n                    j = 0;\n                    count = 0;\n                    window.clear();\n                }\n            }\n            i += 1;\n        }\n\n        if min_window.is_empty() {\n            return \"\".to_string();\n        }\n\n        String::from_utf8(min_window).unwrap()\n    }\n}\n", "36": "\nimpl Solution {\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        // Check rows\n        for row in 0..9 {\n            let mut seen = HashSet::new();\n            for col in 0..9 {\n                if board[row][col] != '.' {\n                    let digit = board[row][col] as u8 - '0' as u8;\n                    if seen.contains(&digit) {\n                        return false;\n                    }\n                    seen.insert(digit);\n                }\n            }\n        }\n\n        // Check columns\n        for col in 0..9 {\n            let mut seen = HashSet::new();\n            for row in 0..9 {\n                if board[row][col] != '.' {\n                    let digit = board[row][col] as u8 - '0' as u8;\n                    if seen.contains(&digit) {\n                        return false;\n                    }\n                    seen.insert(digit);\n                }\n            }\n        }\n\n        // Check sub-boxes\n        for sub_box_row in 0..3 {\n            for sub_box_col in 0..3 {\n                let mut seen = HashSet::new();\n                for row in sub_box_row * 3..(sub_box_row + 1) * 3 {\n                    for col in sub_box_col * 3..(sub_box_col + 1) * 3 {\n                        if board[row][col] != '.' {\n                            let digit = board[row][col] as u8 - '0' as u8;\n                            if seen.contains(&digit) {\n                                return false;\n                            }\n                            seen.insert(digit);\n                        }\n                    }\n                }\n            }\n        }\n\n        true\n    }\n}\n", "54": "\nimpl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut top = 0;\n        let mut bottom = matrix.len() - 1;\n        let mut left = 0;\n        let mut right = matrix[0].len() - 1;\n\n        while top <= bottom && left <= right {\n            for i in left..=right {\n                result.push(matrix[top][i]);\n            }\n            top += 1;\n\n            for i in top..=bottom {\n                result.push(matrix[i][right]);\n            }\n            right -= 1;\n\n            if top <= bottom {\n                for i in (left..=right).rev() {\n                    result.push(matrix[bottom][i]);\n                }\n                bottom -= 1;\n            }\n\n            if left <= right {\n                for i in (top..=bottom).rev() {\n                    result.push(matrix[i][left]);\n                }\n                left += 1;\n            }\n        }\n\n        result\n    }\n}\n", "48": "\nimpl Solution {\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        let n = matrix.len();\n        for i in 0..n {\n            for j in i..n {\n                let temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for i in 0..n {\n            for j in 0..(n + 1) / 2 {\n                let temp = matrix[i][j];\n                matrix[i][j] = matrix[i][n - j - 1];\n                matrix[i][n - j - 1] = temp;\n            }\n        }\n    }\n}\n", "73": "\nimpl Solution {\n    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        let m = matrix.len();\n        let n = matrix[0].len();\n\n        // Find the first row and column with a zero element\n        let mut first_row = 0;\n        let mut first_col = 0;\n        for i in 0..m {\n            for j in 0..n {\n                if matrix[i][j] == 0 {\n                    first_row = i;\n                    first_col = j;\n                    break;\n                }\n            }\n        }\n\n        // Set the first row and column to zero\n        for i in 0..m {\n            matrix[i][first_col] = 0;\n        }\n        for j in 0..n {\n            matrix[first_row][j] = 0;\n        }\n\n        // Set all other zero elements to zero\n        for i in 1..m {\n            for j in 1..n {\n                if matrix[i][j] == 0 {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n", "289": "\nimpl Solution {\n    pub fn game_of_life(board: &mut Vec<Vec<i32>>) {\n        let m = board.len();\n        let n = board[0].len();\n\n        for i in 0..m {\n            for j in 0..n {\n                let neighbors = get_neighbors(board, i, j);\n                let next_state = get_next_state(board[i][j], neighbors);\n                board[i][j] = next_state;\n            }\n        }\n    }\n\n    fn get_neighbors(board: &Vec<Vec<i32>>, i: usize, j: usize) -> Vec<i32> {\n        let mut neighbors = Vec::new();\n\n        for k in -1..=1 {\n            for l in -1..=1 {\n                if k == 0 && l == 0 {\n                    continue;\n                }\n\n                let x = i as i32 + k;\n                let y = j as i32 + l;\n\n                if x < 0 || x >= m as i32 || y < 0 || y >= n as i32 {\n                    continue;\n                }\n\n                neighbors.push(board[x as usize][y as usize]);\n            }\n        }\n\n        neighbors\n    }\n\n    fn get_next_state(current_state: i32, neighbors: Vec<i32>) -> i32 {\n        let mut next_state = current_state;\n\n        if current_state == 1 {\n            if neighbors.iter().filter(|&x| x == 1).count() < 2 {\n                next_state = 0;\n            } else if neighbors.iter().filter(|&x| x == 1).count() == 2 || neighbors.iter().filter(|&x| x == 1).count() == 3 {\n                next_state = 1;\n            } else if neighbors.iter().filter(|&x| x == 1).count() > ", "383": "\nimpl Solution {\n    pub fn can_construct(ransom_note: String, magazine: String) -> bool {\n        let mut magazine_chars = magazine.chars().collect::<Vec<char>>();\n        let mut ransom_note_chars = ransom_note.chars().collect::<Vec<char>>();\n\n        for ransom_note_char in ransom_note_chars {\n            if let Some(index) = magazine_chars.iter().position(|c| *c == ransom_note_char) {\n                magazine_chars.remove(index);\n            } else {\n                return false;\n            }\n        }\n\n        true\n    }\n}\n", "205": "\nimpl Solution {\n    pub fn is_isomorphic(s: String, t: String) -> bool {\n        let mut s_map = HashMap::new();\n        let mut t_map = HashMap::new();\n\n        for (i, c) in s.chars().enumerate() {\n            if s_map.contains_key(&c) {\n                if s_map[&c] != t.chars().nth(i).unwrap() {\n                    return false;\n                }\n            } else {\n                s_map.insert(c, t.chars().nth(i).unwrap());\n            }\n        }\n\n        for (i, c) in t.chars().enumerate() {\n            if t_map.contains_key(&c) {\n                if t_map[&c] != s.chars().nth(i).unwrap() {\n                    return false;\n                }\n            } else {\n                t_map.insert(c, s.chars().nth(i).unwrap());\n            }\n        }\n\n        true\n    }\n}\n", "290": "\nimpl Solution {\n    pub fn word_pattern(pattern: String, s: String) -> bool {\n        let mut pattern_iter = pattern.chars();\n        let mut s_iter = s.split_whitespace();\n\n        while let Some(pattern_char) = pattern_iter.next() {\n            if let Some(word) = s_iter.next() {\n                if word.is_empty() {\n                    return false;\n                }\n                if pattern_char != word.chars().next().unwrap() {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        true\n    }\n}\n", "242": "\nimpl Solution {\n    pub fn is_anagram(s: String, t: String) -> bool {\n        let mut s_chars = s.chars().collect::<Vec<char>>();\n        let mut t_chars = t.chars().collect::<Vec<char>>();\n\n        s_chars.sort();\n        t_chars.sort();\n\n        s_chars == t_chars\n    }\n}\n", "49": "\nimpl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        let mut anagrams: Vec<Vec<String>> = vec![];\n        for s in strs {\n            let mut anagram = vec![];\n            for c in s.chars() {\n                anagram.push(c);\n            }\n            anagram.sort();\n            let mut found = false;\n            for i in 0..anagrams.len() {\n                if anagrams[i] == anagram {\n                    anagrams[i].push(s);\n                    found = true;\n                    break;\n                }\n            }\n            if !found {\n                anagrams.push(vec![s]);\n            }\n        }\n        anagrams\n    }\n}\n", "1": "\nimpl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut result = Vec::new();\n        for i in 0..nums.len() {\n            for j in (i + 1)..nums.len() {\n                if nums[i] + nums[j] == target {\n                    result.push(i as i32);\n                    result.push(j as i32);\n                    return result;\n                }\n            }\n        }\n        result\n    }\n}\n", "202": "\nimpl Solution {\n    pub fn is_happy(n: i32) -> bool {\n        let mut seen = HashSet::new();\n        let mut current = n;\n        while current != 1 {\n            if seen.contains(&current) {\n                return false;\n            }\n            seen.insert(current);\n            current = Self::sum_of_squares(current);\n        }\n        true\n    }\n\n    fn sum_of_squares(n: i32) -> i32 {\n        let mut sum = 0;\n        for digit in n.to_string().chars() {\n            sum += digit.to_digit(10).unwrap().pow(2);\n        }\n        sum\n    }\n}\n", "219": "\nimpl Solution {\n    pub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\n        let mut seen = HashSet::new();\n        for (i, &num) in nums.iter().enumerate() {\n            if seen.contains(&num) {\n                return true;\n            }\n            seen.insert(num);\n            if i >= k as usize {\n                seen.remove(&nums[i - k as usize]);\n            }\n        }\n        false\n    }\n}\n", "128": "\nimpl Solution {\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\n        let mut longest = 0;\n        let mut seen = HashSet::new();\n\n        for &num in nums.iter() {\n            if seen.contains(&(num - 1)) {\n                continue;\n            }\n\n            let mut current = num;\n            let mut count = 1;\n\n            while seen.contains(&current) {\n                count += 1;\n                current += 1;\n            }\n\n            longest = std::cmp::max(longest, count);\n            seen.insert(num);\n        }\n\n        longest\n    }\n}\n", "228": "\nimpl Solution {\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\n        let mut ranges = Vec::new();\n        let mut start = 0;\n        let mut end = 0;\n\n        for i in 1..nums.len() {\n            if nums[i] == nums[i - 1] + 1 {\n                end = i;\n            } else {\n                ranges.push(format!(\"{}->{}\", nums[start], nums[end]));\n                start = i;\n                end = i;\n            }\n        }\n\n        ranges.push(format!(\"{}->{}\", nums[start], nums[end]));\n\n        ranges\n    }\n}\n", "56": "\nimpl Solution {\n    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut merged_intervals = Vec::new();\n\n        for interval in intervals {\n            let start = interval[0];\n            let end = interval[1];\n\n            if merged_intervals.is_empty() {\n                merged_intervals.push(vec![start, end]);\n            } else {\n                let last_interval = merged_intervals.last().unwrap();\n                let last_start = last_interval[0];\n                let last_end = last_interval[1];\n\n                if start <= last_end {\n                    last_interval[1] = max(last_end, end);\n                } else {\n                    merged_intervals.push(vec![start, end]);\n                }\n            }\n        }\n\n        merged_intervals\n    }\n}\n", "57": "\nimpl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut intervals = intervals;\n        let mut new_interval = new_interval;\n\n        // Check if the new interval overlaps with any of the existing intervals\n        for i in 0..intervals.len() {\n            if new_interval[0] <= intervals[i][1] && new_interval[1] >= intervals[i][0] {\n                // Merge the new interval with the existing interval\n                new_interval[0] = min(new_interval[0], intervals[i][0]);\n                new_interval[1] = max(new_interval[1], intervals[i][1]);\n                intervals.remove(i);\n                break;\n            }\n        }\n\n        // Insert the new interval into the sorted list of intervals\n        intervals.push(new_interval);\n        intervals.sort_by(|a, b| a[0].cmp(&b[0]));\n\n        intervals\n    }\n}\n", "452": "\nimpl Solution {\n    pub fn find_min_arrow_shots(points: Vec<Vec<i32>>) -> i32 {\n        let mut balloons = Vec::new();\n        for point in points {\n            balloons.push(Balloon::new(point[0], point[1]));\n        }\n\n        let mut arrows = Vec::new();\n        let mut min_arrows = 0;\n\n        while !balloons.is_empty() {\n            let mut burst_balloons = Vec::new();\n            for balloon in &balloons {\n                if balloon.xstart <= 0 && balloon.xend >= 0 {\n                    burst_balloons.push(balloon.clone());\n                }\n            }\n\n            if !burst_balloons.is_empty() {\n                min_arrows += 1;\n                for balloon in &burst_balloons {\n                    balloons.remove(balloon);\n                }\n            }\n\n            if balloons.is_empty() {\n                break;\n            }\n\n            arrows.push(Arrow::new(0, 0));\n            for balloon in &balloons {\n                if balloon.xstart <= 0 && balloon.xend >= 0 {\n                    arrows.push(Arrow::new(balloon.xstart, balloon.xend));\n                }\n            }\n\n            for arrow in &arrows {\n                for balloon in &balloons {\n                    if arrow.xstart <= balloon.xend && arrow.xend >= balloon.xstart {\n                        balloons.remove(balloon);\n                    }\n                }\n            }\n        }\n\n        min_arrows\n    }\n}\n\nstruct Balloon {\n    xstart: i32,\n    xend: i32,\n}\n\nimpl Balloon {\n    fn new(xstart: i32,", "20": "\nimpl Solution {\n    pub fn is_valid(s: String) -> bool {\n        let mut stack = Vec::new();\n\n        for c in s.chars() {\n            match c {\n                '(' | '[' | '{' => stack.push(c),\n                ')' | ']' | '}' => {\n                    if stack.is_empty() || stack.pop().unwrap() != c {\n                        return false;\n                    }\n                }\n                _ => panic!(\"Invalid character: {}\", c),\n            }\n        }\n\n        stack.is_empty()\n    }\n}\n", "71": "\ndef simplify_path(path: str) -> str:\n    tokens = path.split(\"/\")\n    stack = []\n    for token in tokens:\n        if token == \"..\":\n            if stack:\n                stack.pop()\n        elif token != \".\":\n            stack.append(token)\n    return \"/\" + \"/\".join(stack)\n", "155": "\nstruct MinStack {\n    stack: Vec<i32>,\n    min_stack: Vec<i32>,\n}\n\nimpl MinStack {\n    fn new() -> Self {\n        Self {\n            stack: Vec::new(),\n            min_stack: Vec::new(),\n        }\n    }\n\n    fn push(&mut self, val: i32) {\n        self.stack.push(val);\n        if self.min_stack.is_empty() || val < self.min_stack.last().unwrap() {\n            self.min_stack.push(val);\n        } else {\n            self.min_stack.push(self.min_stack.last().unwrap());\n        }\n    }\n\n    fn pop(&mut self) {\n        self.stack.pop();\n        self.min_stack.pop();\n    }\n\n    fn top(&self) -> i32 {\n        self.stack.last().unwrap()\n    }\n\n    fn get_min(&self) -> i32 {\n        self.min_stack.last().unwrap()\n    }\n}\n", "150": "\nimpl Solution {\n    pub fn eval_rpn(tokens: Vec<String>) -> i32 {\n        let mut stack = Vec::new();\n\n        for token in tokens {\n            match token.as_str() {\n                \"+\" => {\n                    let b = stack.pop().unwrap();\n                    let a = stack.pop().unwrap();\n                    stack.push(a + b);\n                }\n                \"-\" => {\n                    let b = stack.pop().unwrap();\n                    let a = stack.pop().unwrap();\n                    stack.push(a - b);\n                }\n                \"*\" => {\n                    let b = stack.pop().unwrap();\n                    let a = stack.pop().unwrap();\n                    stack.push(a * b);\n                }\n                \"/\" => {\n                    let b = stack.pop().unwrap();\n                    let a = stack.pop().unwrap();\n                    stack.push(a / b);\n                }\n                _ => {\n                    stack.push(token.parse::<i32>().unwrap());\n                }\n            }\n        }\n\n        stack.pop().unwrap()\n    }\n}\n", "224": "\nimpl Solution {\n    pub fn calculate(s: String) -> i32 {\n        let mut stack = Vec::new();\n        let mut result = 0;\n        let mut operator = '+';\n\n        for c in s.chars() {\n            match c {\n                '+' | '-' => {\n                    if operator == '+' {\n                        result += stack.pop().unwrap();\n                    } else {\n                        result -= stack.pop().unwrap();\n                    }\n                    operator = c;\n                }\n                '(' => {\n                    stack.push(result);\n                    result = 0;\n                    operator = '+';\n                }\n                ')' => {\n                    result += stack.pop().unwrap();\n                    operator = '+';\n                }\n                _ => {\n                    result = result * 10 + c.to_digit(10).unwrap();\n                }\n            }\n        }\n\n        if operator == '+' {\n            result += stack.pop().unwrap();\n        } else {\n            result -= stack.pop().unwrap();\n        }\n\n        result\n    }\n}\n", "141": "\nuse std::collections::HashSet;\n\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    fn new(val: i32) -> Self {\n        ListNode { val, next: None }\n    }\n}\n\nstruct Solution {}\n\nimpl Solution {\n    fn has_cycle(head: &ListNode) -> bool {\n        let mut set = HashSet::new();\n        let mut curr = head;\n\n        while let Some(node) = curr {\n            if set.contains(node) {\n                return true;\n            }\n            set.insert(node);\n            curr = node.next;\n        }\n\n        false\n    }\n}\n", "2": "\nuse std::option::Option;\n\npub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n    let mut result = ListNode::new(0);\n    let mut carry = 0;\n\n    let mut l1_iter = l1.into_iter();\n    let mut l2_iter = l2.into_iter();\n\n    while l1_iter.next().is_some() || l2_iter.next().is_some() {\n        let mut sum = carry;\n\n        if let Some(node) = l1_iter.next() {\n            sum += node.val;\n        }\n\n        if let Some(node) = l2_iter.next() {\n            sum += node.val;\n        }\n\n        result.next = Some(Box::new(ListNode::new(sum % 10)));\n        carry = sum / 10;\n    }\n\n    if carry > 0 {\n        result.next = Some(Box::new(ListNode::new(carry)));\n    }\n\n    Some(Box::new(result))\n}\n", "21": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = ListNode(0)\n        tail = dummy\n        while list1 and list2:\n            if list1.val <= list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        tail.next = list1 or list2\n        return dummy.next\n", "138": "\nuse std::collections::HashMap;\n\nstruct Node {\n    val: i32,\n    next: Option<Box<Node>>,\n    random: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(val: i32) -> Self {\n        Self {\n            val,\n            next: None,\n            random: None,\n        }\n    }\n}\n\nfn copy_random_list(head: Option<Box<Node>>) -> Option<Box<Node>> {\n    if head.is_none() {\n        return None;\n    }\n\n    let mut map = HashMap::new();\n    let mut current = head;\n    while let Some(node) = current {\n        map.insert(node.val, node.clone());\n        current = node.next;\n    }\n\n    let mut current = head;\n    while let Some(node) = current {\n        let mut new_node = Node::new(node.val);\n        new_node.next = map.get(&node.next.unwrap().val).cloned();\n        new_node.random = map.get(&node.random.unwrap().val).cloned();\n        current = new_node.next;\n    }\n\n    head\n}\n", "92": "\nuse std::option::Option;\nuse std::boxed::Box;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\n        let mut current = head;\n        let mut previous = None;\n        let mut count = 0;\n\n        while let Some(node) = current {\n            if count == left - 1 {\n                previous = Some(node);\n            } else if count == right {\n                break;\n            }\n\n            count += 1;\n            current = node.next;\n        }\n\n        if let Some(previous) = previous {\n            let mut new_head = previous.next;\n            previous.next = None;\n            current = new_head;\n\n            while let Some(node) = current {\n                let next = node.next;\n                node.next = previous;\n                previous = Some(node);\n                current = next;\n            }\n\n            return Some(previous);\n        }\n\n        None\n    }\n}\n", "25": "\nuse std::option::Option;\n\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nstruct Solution;\n\nimpl Solution {\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        let mut current = head;\n        let mut previous = None;\n        let mut count = 0;\n\n        while let Some(node) = current {\n            count += 1;\n            if count == k {\n                break;\n            }\n            current = node.next;\n        }\n\n        if count < k {\n            return head;\n        }\n\n        let mut new_head = current;\n        let mut new_tail = None;\n\n        while let Some(node) = current {\n            let mut next = node.next;\n            node.next = previous;\n            previous = Some(node);\n            current = next;\n        }\n\n        new_head.next = previous;\n        new_tail = new_head;\n\n        while let Some(node) = new_tail {\n            if node.next.is_none() {\n                break;\n            }\n            new_tail = node.next;\n        }\n\n        new_tail.next = None;\n\n        new_head\n    }\n}\n", "19": "\nuse std::option::Option;\nuse std::boxed::Box;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        let mut head = head;\n        let mut n = n;\n        let mut current = head;\n        let mut previous = None;\n\n        while n > 0 {\n            previous = current;\n            current = current.next;\n            n -= 1;\n        }\n\n        if previous.is_none() {\n            head = current.next;\n        } else {\n            previous.unwrap().next = current.next;\n        }\n\n        head\n    }\n}\n", "82": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        dummy = ListNode(0, head)\n        prev = dummy\n        while prev.next and prev.next.next:\n            if prev.next.val == prev.next.next.val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n        return dummy.next\n", "61": "\nuse std::option::Option;\n\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        if head.is_none() {\n            return head;\n        }\n\n        let mut length = 0;\n        let mut current = head;\n        while current.is_some() {\n            length += 1;\n            current = current.unwrap().next;\n        }\n\n        let k = k % length;\n        if k == 0 {\n            return head;\n        }\n\n        let mut new_head = head;\n        for _ in 0..(length - k) {\n            new_head = new_head.unwrap().next;\n        }\n\n        let mut current = head;\n        while current.is_some() {\n            let next = current.unwrap().next;\n            current.unwrap().next = new_head;\n            current = next;\n        }\n\n        new_head\n    }\n}\n", "86": "\nuse std::option::Option;\nuse std::boxed::Box;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        let mut less_than_x = Vec::new();\n        let mut greater_than_or_equal_to_x = Vec::new();\n\n        let mut current = head;\n        while let Some(node) = current {\n            if node.val < x {\n                less_than_x.push(node);\n            } else {\n                greater_than_or_equal_to_x.push(node);\n            }\n            current = node.next;\n        }\n\n        let mut result = None;\n        for node in less_than_x {\n            result = Some(Box::new(ListNode {\n                val: node.val,\n                next: result,\n            }));\n        }\n        for node in greater_than_or_equal_to_x {\n            result = Some(Box::new(ListNode {\n                val: node.val,\n                next: result,\n            }));\n        }\n\n        result\n    }\n}\n", "146": "\nstruct LRUCache {\n    capacity: i32,\n    map: HashMap<i32, i32>,\n    queue: VecDeque<i32>,\n}\n\nimpl LRUCache {\n    fn new(capacity: i32) -> Self {\n        LRUCache {\n            capacity,\n            map: HashMap::new(),\n            queue: VecDeque::new(),\n        }\n    }\n\n    fn get(&self, key: i32) -> i32 {\n        if let Some(value) = self.map.get(&key) {\n            self.queue.push_front(key);\n            *value\n        } else {\n            -1\n        }\n    }\n\n    fn put(&mut self, key: i32, value: i32) {\n        if let Some(old_value) = self.map.insert(key, value) {\n            self.queue.remove(&old_value);\n        }\n        self.queue.push_front(key);\n        if self.queue.len() > self.capacity {\n            let evicted_key = self.queue.pop_back().unwrap();\n            self.map.remove(&evicted_key);\n        }\n    }\n}\n", "104": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        match root {\n            None => 0,\n            Some(node) => {\n                let left_depth = Solution::max_depth(node.borrow().left.clone());\n                let right_depth = Solution::max_depth(node.borrow().right.clone());\n                std::cmp::max(left_depth, right_depth) + 1\n            }\n        }\n    }\n}\n", "100": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        match (p, q) {\n            (None, None) => true,\n            (Some(p), Some(q)) => {\n                let p_val = p.borrow().val;\n                let q_val = q.borrow().val;\n                if p_val != q_val {\n                    return false;\n                }\n                Solution::is_same_tree(p.borrow().left, q.borrow().left) &&\n                    Solution::is_same_tree(p.borrow().right, q.borrow().right)\n            }\n            _ => false,\n        }\n    }\n}\n", "226": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        match root {\n            Some(node) => {\n                let mut new_node = Rc::new(RefCell::new(TreeNode::new(node.borrow().val)));\n                new_node.borrow_mut().left = Self::invert_tree(node.borrow().right.clone());\n                new_node.borrow_mut().right = Self::invert_tree(node.borrow().left.clone());\n                Some(new_node)\n            },\n            None => None,\n        }\n    }\n}\n", "101": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool {\n            match (left, right) {\n                (None, None) => true,\n                (Some(l), Some(r)) => {\n                    l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_deref())\n                }\n                _ => false,\n            }\n        }\n\n        is_symmetric_helper(root, root)\n    }\n}\n", "105": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        if preorder.is_empty() || inorder.is_empty() {\n            return None;\n        }\n\n        let root_val = preorder[0];\n        let root = TreeNode::new(root_val);\n\n        let mut preorder_idx = 1;\n        let mut inorder_idx = 0;\n        while inorder_idx < inorder.len() && inorder[inorder_idx] != root_val {\n            inorder_idx += 1;\n        }\n\n        root.left = Self::build_tree(preorder[1..preorder_idx].to_vec(), inorder[0..inorder_idx].to_vec());\n        root.right = Self::build_tree(preorder[preorder_idx..].to_vec(), inorder[inorder_idx+1..].to_vec());\n\n        Some(Rc::new(RefCell::new(root)))\n    }\n}\n", "106": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        if inorder.is_empty() || postorder.is_empty() {\n            return None;\n        }\n\n        let root_val = postorder.pop().unwrap();\n        let root = TreeNode::new(root_val);\n\n        let mut inorder_idx = 0;\n        for i in 0..inorder.len() {\n            if inorder[i] == root_val {\n                inorder_idx = i;\n                break;\n            }\n        }\n\n        root.left = Self::build_tree(inorder[0..inorder_idx].to_vec(), postorder[0..inorder_idx].to_vec());\n        root.right = Self::build_tree(inorder[inorder_idx+1..].to_vec(), postorder[inorder_idx+1..].to_vec());\n\n        Some(Rc::new(RefCell::new(root)))\n    }\n}\n", "117": "\nuse std::ptr;\n\nstruct Node {\n    int val;\n    Node *left;\n    Node *right;\n    Node *next;\n}\n\nimpl Solution {\n    fn connect(root: &mut Node) {\n        if root.left.is_some() {\n            root.left.as_mut().unwrap().next = root.right;\n        }\n        if root.right.is_some() {\n            root.right.as_mut().unwrap().next = root.next;\n        }\n        if root.left.is_some() {\n            Solution::connect(root.left.as_mut().unwrap());\n        }\n        if root.right.is_some() {\n            Solution::connect(root.right.as_mut().unwrap());\n        }\n    }\n}\n", "114": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn flatten(root: &mut Option<Rc<RefCell<TreeNode>>>) {\n        if let Some(node) = root {\n            let mut current = node;\n            let mut next = current.borrow_mut().right.take();\n            while let Some(mut next) = next {\n                let mut next_next = next.borrow_mut().right.take();\n                current.borrow_mut().right = Some(next);\n                current = next;\n                next = next_next;\n            }\n            current.borrow_mut().right = None;\n        }\n    }\n}\n", "112": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> bool {\n        if root.is_none() {\n            return false;\n        }\n\n        let root = root.unwrap();\n        let val = root.borrow().val;\n\n        if root.borrow().left.is_none() && root.borrow().right.is_none() {\n            return val == target_sum;\n        }\n\n        return Solution::has_path_sum(root.borrow().left.clone(), target_sum - val) ||\n               Solution::has_path_sum(root.borrow().right.clone(), target_sum - val);\n    }\n}\n", "129": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut sum = 0;\n        Self::sum_numbers_helper(root, &mut sum);\n        sum\n    }\n\n    fn sum_numbers_helper(node: Option<Rc<RefCell<TreeNode>>>, sum: &mut i32) {\n        if let Some(node) = node {\n            let node = node.borrow();\n            *sum += node.val;\n            Self::sum_numbers_helper(node.left, sum);\n            Self::sum_numbers_helper(node.right, sum);\n        }\n    }\n}\n", "124": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut max_sum = i32::MIN;\n        Self::dfs(root, &mut max_sum);\n        max_sum\n    }\n\n    fn dfs(node: Option<Rc<RefCell<TreeNode>>>, max_sum: &mut i32) {\n        if let Some(node) = node {\n            let node = node.borrow();\n            let left_sum = Self::dfs(node.left.clone(), max_sum);\n            let right_sum = Self::dfs(node.right.clone(), max_sum);\n            let sum = node.val + left_sum + right_sum;\n            *max_sum = max(*max_sum, sum);\n            sum\n        } else {\n            0\n        }\n    }\n}\n", "173": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\nstruct BSTIterator {\n    current: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl BSTIterator {\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        BSTIterator {\n            current: root,\n        }\n    }\n\n    fn next(&mut self) -> i32 {\n        if let Some(node) = self.current {\n            let val = node.borrow().val;\n            self.current = node.borrow().right.clone();\n            val\n        } else {\n            panic!(\"No more elements in the iterator\")\n        }\n    }\n\n    fn has_next(&self) -> bool {\n        self.current.is_some()\n    }\n}\n", "222": "\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def count_nodes(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        height = 0\n        node = root\n        while node.left is not None:\n            height += 1\n            node = node.left\n        nodes_in_last_level = 2 ** height\n        nodes_in_other_levels = 2 ** (height - 1) - 1\n        return nodes_in_last_level + nodes_in_other_levels * self.count_nodes(root.left)\n", "236": "\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef lowest_common_ancestor(root: Optional[TreeNode], p: Optional[TreeNode], q: Optional[TreeNode]) -> Optional[TreeNode]:\n    if not root or root == p or root == q:\n        return root\n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n    if left and right:\n        return root\n    return left or right\n", "199": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut queue = Vec::new();\n        queue.push(root);\n        while let Some(node) = queue.pop() {\n            if let Some(node) = node {\n                result.push(node.borrow().val);\n                queue.push(node.borrow().right.clone());\n                queue.push(node.borrow().left.clone());\n            }\n        }\n        result\n    }\n}\n", "637": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn average_of_levels(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<f64> {\n        let mut queue = Vec::new();\n        let mut result = Vec::new();\n\n        if let Some(root) = root {\n            queue.push(root);\n        }\n\n        while !queue.is_empty() {\n            let mut sum = 0;\n            let mut count = 0;\n\n            for node in queue.drain(..) {\n                sum += node.borrow().val;\n                count += 1;\n\n                if let Some(left) = node.borrow().left.clone() {\n                    queue.push(left);\n                }\n\n                if let Some(right) = node.borrow().right.clone() {\n                    queue.push(right);\n                }\n            }\n\n            result.push(sum as f64 / count as f64);\n        }\n\n        result\n    }\n}\n", "102": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut queue = Vec::new();\n        queue.push(root);\n        while !queue.is_empty() {\n            let mut level = Vec::new();\n            for node in queue.drain(..) {\n                if let Some(node) = node {\n                    level.push(node.borrow().val);\n                    if let Some(left) = node.borrow().left.clone() {\n                        queue.push(left);\n                    }\n                    if let Some(right) = node.borrow().right.clone() {\n                        queue.push(right);\n                    }\n                }\n            }\n            result.push(level);\n        }\n        result\n    }\n}\n", "103": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn zigzag_level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut queue = Vec::new();\n        let mut level = 0;\n\n        if let Some(root) = root {\n            queue.push(root);\n        }\n\n        while !queue.is_empty() {\n            let mut current_level = Vec::new();\n            for _ in 0..queue.len() {\n                let node = queue.pop().unwrap();\n                current_level.push(node.borrow().val);\n                if let Some(left) = node.borrow().left.clone() {\n                    queue.push(left);\n                }\n                if let Some(right) = node.borrow().right.clone() {\n                    queue.push(right);\n                }\n            }\n            if level % 2 == 0 {\n                current_level.reverse();\n            }\n            result.push(current_level);\n            level += 1;\n        }\n\n        result\n    }\n}\n", "530": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn get_minimum_difference(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut min_diff = i32::MAX;\n        let mut prev_val = i32::MIN;\n\n        Self::inorder_traversal(root, &mut min_diff, &mut prev_val);\n\n        min_diff\n    }\n\n    fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>, min_diff: &mut i32, prev_val: &mut i32) {\n        if let Some(node) = root {\n            Self::inorder_traversal(node.left, min_diff, prev_val);\n            let val = node.borrow().val;\n            if *prev_val != i32::MIN {\n                *min_diff = min(*min_diff, val - *prev_val);\n            }\n            *prev_val = val;\n            Self::inorder_traversal(node.right, min_diff, prev_val);\n        }\n    }\n}\n", "230": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::collections::BinaryHeap;\n\nimpl Solution {\n    pub fn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\n        let mut queue = BinaryHeap::new();\n        let mut current = root;\n        while let Some(node) = current {\n            queue.push(node.borrow().val);\n            current = node.borrow().left;\n        }\n        while let Some(node) = current {\n            queue.push(node.borrow().val);\n            current = node.borrow().right;\n        }\n        while queue.len() > k {\n            queue.pop();\n        }\n        queue.pop().unwrap()\n    }\n}\n", "98": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        is_valid_bst_helper(root, None, None)\n    }\n\n    fn is_valid_bst_helper(root: Option<Rc<RefCell<TreeNode>>>, min: Option<i32>, max: Option<i32>) -> bool {\n        if root.is_none() {\n            return true;\n        }\n\n        let root = root.unwrap();\n        let node = root.borrow();\n\n        if min.is_some() && node.val <= min.unwrap() {\n            return false;\n        }\n\n        if max.is_some() && node.val >= max.unwrap() {\n            return false;\n        }\n\n        is_valid_bst_helper(node.left, min, Some(node.val)) && is_valid_bst_helper(node.right, Some(node.val), max)\n    }\n}\n", "200": "\nimpl Solution {\n    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {\n        let mut num_islands = 0;\n        for i in 0..grid.len() {\n            for j in 0..grid[i].len() {\n                if grid[i][j] == '1' {\n                    num_islands += 1;\n                    Self::dfs(grid, i, j);\n                }\n            }\n        }\n        num_islands\n    }\n\n    fn dfs(grid: &Vec<Vec<char>>, i: usize, j: usize) {\n        if i < 0 || i >= grid.len() || j < 0 || j >= grid[i].len() || grid[i][j] == '0' {\n            return;\n        }\n        grid[i][j] = '0';\n        Self::dfs(grid, i - 1, j);\n        Self::dfs(grid, i + 1, j);\n        Self::dfs(grid, i, j - 1);\n        Self::dfs(grid, i, j + 1);\n    }\n}\n", "130": "\nimpl Solution {\n    pub fn solve(board: &mut Vec<Vec<char>>) {\n        let m = board.len();\n        let n = board[0].len();\n\n        for i in 0..m {\n            for j in 0..n {\n                if board[i][j] == 'O' {\n                    // Check if the current cell is surrounded by 'X'\n                    let mut is_surrounded = true;\n                    for k in 0..4 {\n                        let row = i as i32 + directions[k][0];\n                        let col = j as i32 + directions[k][1];\n                        if row < 0 || row >= m as i32 || col < 0 || col >= n as i32 {\n                            continue;\n                        }\n                        if board[row as usize][col as usize] != 'X' {\n                            is_surrounded = false;\n                            break;\n                        }\n                    }\n\n                    // Flip the current cell if it is surrounded by 'X'\n                    if is_surrounded {\n                        board[i][j] = 'X';\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Directions to check for surrounding 'X'\nconst directions: [[i32; 2]; 4] = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n", "133": "\nuse std::collections::HashMap;\n\nstruct Node {\n    val: i32,\n    neighbors: Vec<Node>,\n}\n\nimpl Clone for Node {\n    fn clone(&self) -> Self {\n        Node {\n            val: self.val,\n            neighbors: self.neighbors.iter().map(|neighbor| neighbor.clone()).collect(),\n        }\n    }\n}\n\nfn clone_graph(node: &Node) -> Node {\n    let mut visited = HashMap::new();\n    let mut queue = Vec::new();\n    queue.push(node.clone());\n    while let Some(node) = queue.pop() {\n        if visited.contains_key(&node.val) {\n            continue;\n        }\n        visited.insert(node.val, node.clone());\n        for neighbor in node.neighbors.iter() {\n            queue.push(neighbor.clone());\n        }\n    }\n    visited.remove(&node.val).unwrap()\n}\n", "399": "\nimpl Solution {\n    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\n        let mut variables: HashMap<String, f64> = HashMap::new();\n        for (i, equation) in equations.iter().enumerate() {\n            let (var1, var2) = (equation[0].clone(), equation[1].clone());\n            let value = values[i];\n            variables.insert(var1, value);\n            variables.insert(var2, 1.0 / value);\n        }\n        let mut results: Vec<f64> = Vec::new();\n        for query in queries {\n            let (var1, var2) = (query[0].clone(), query[1].clone());\n            if variables.contains_key(&var1) && variables.contains_key(&var2) {\n                let value1 = variables[&var1];\n                let value2 = variables[&var2];\n                results.push(value1 * value2);\n            } else {\n                results.push(-1.0);\n            }\n        }\n        results\n    }\n}\n", "207": "\nimpl Solution {\n    pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        let mut graph = vec![vec![]; num_courses as usize];\n        for edge in prerequisites {\n            graph[edge[1] as usize].push(edge[0] as usize);\n        }\n        let mut visited = vec![false; num_courses as usize];\n        let mut stack = vec![];\n        for i in 0..num_courses {\n            if !visited[i] {\n                if !dfs(i, &mut graph, &mut visited, &mut stack) {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n}\n\nfn dfs(node: usize, graph: &mut Vec<Vec<usize>>, visited: &mut Vec<bool>, stack: &mut Vec<usize>) -> bool {\n    if visited[node] {\n        return false;\n    }\n    visited[node] = true;\n    stack.push(node);\n    for neighbor in graph[node].iter() {\n        if !dfs(*neighbor, graph, visited, stack) {\n            return false;\n        }\n    }\n    stack.pop();\n    true\n}\n", "210": "\nimpl Solution {\n    pub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut graph = vec![vec![]; num_courses as usize];\n        let mut in_degree = vec![0; num_courses as usize];\n        let mut queue = Vec::new();\n        let mut result = Vec::new();\n\n        for edge in prerequisites {\n            let (course, prereq) = (edge[0] as usize, edge[1] as usize);\n            graph[prereq].push(course);\n            in_degree[course] += 1;\n        }\n\n        for i in 0..num_courses {\n            if in_degree[i] == 0 {\n                queue.push(i);\n            }\n        }\n\n        while !queue.is_empty() {\n            let course = queue.pop().unwrap();\n            result.push(course);\n            for neighbor in graph[course].iter() {\n                in_degree[*neighbor] -= 1;\n                if in_degree[*neighbor] == 0 {\n                    queue.push(*neighbor);\n                }\n            }\n        }\n\n        if result.len() == num_courses as usize {\n            result\n        } else {\n            vec![]\n        }\n    }\n}\n", "909": "\nimpl Solution {\n    pub fn snakes_and_ladders(board: Vec<Vec<i32>>) -> i32 {\n        let n = board.len();\n        let mut moves = 0;\n        let mut current = 1;\n        let mut next = 1;\n\n        while current != n * n {\n            next = current + 1;\n            if next > n * n {\n                next = n * n;\n            }\n\n            if board[current / n][current % n] != -1 {\n                next = board[current / n][current % n];\n            }\n\n            if next == n * n {\n                return moves;\n            }\n\n            current = next;\n            moves += 1;\n        }\n\n        return -1;\n    }\n}\n", "433": "\nimpl Solution {\n    pub fn min_mutation(start_gene: String, end_gene: String, bank: Vec<String>) -> i32 {\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        queue.push_back((start_gene, 0));\n        while let Some((gene, depth)) = queue.pop_front() {\n            if gene == end_gene {\n                return depth;\n            }\n            for &mutation in bank.iter() {\n                let new_gene = mutate(gene, mutation);\n                if !visited.contains(&new_gene) {\n                    visited.insert(new_gene);\n                    queue.push_back((new_gene, depth + 1));\n                }\n            }\n        }\n        -1\n    }\n}\n\nfn mutate(gene: String, mutation: String) -> String {\n    let mut new_gene = String::new();\n    for (i, c) in gene.chars().enumerate() {\n        if i < mutation.len() && c != mutation[i] {\n            new_gene.push(mutation[i]);\n        } else {\n            new_gene.push(c);\n        }\n    }\n    new_gene\n}\n", "127": "\nimpl Solution {\n    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        queue.push_back((begin_word, 0));\n        while let Some((word, level)) = queue.pop_front() {\n            if word == end_word {\n                return level;\n            }\n            for &neighbor in word_list.iter().filter(|&neighbor| neighbor != word && neighbor.starts_with(word)) {\n                if !visited.contains(&neighbor) {\n                    visited.insert(neighbor);\n                    queue.push_back((neighbor, level + 1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n", "208": "\nstruct Trie {\n    root: Option<Box<TrieNode>>,\n}\n\nimpl Trie {\n    fn new() -> Self {\n        Self { root: None }\n    }\n\n    fn insert(&mut self, word: String) {\n        let mut node = self.root.take();\n        for c in word.chars() {\n            if node.is_none() {\n                node = Some(Box::new(TrieNode::new()));\n            }\n            node = node.as_mut().unwrap().children.get_mut(c).map(|n| n.as_mut());\n        }\n        node.unwrap().is_end = true;\n        self.root = node;\n    }\n\n    fn search(&self, word: String) -> bool {\n        let mut node = self.root.as_ref();\n        for c in word.chars() {\n            if node.is_none() {\n                return false;\n            }\n            node = node.unwrap().children.get(c);\n        }\n        node.unwrap().is_end\n    }\n\n    fn starts_with(&self, prefix: String) -> bool {\n        let mut node = self.root.as_ref();\n        for c in prefix.chars() {\n            if node.is_none() {\n                return false;\n            }\n            node = node.unwrap().children.get(c);\n        }\n        node.is_some()\n    }\n}\n\nstruct TrieNode {\n    children: HashMap<char, Box<TrieNode>>,\n    is_end: bool,\n}\n\nimpl TrieNode {\n    fn new() -> Self {\n        Self {\n            children: HashMap::new(),\n            is_end: false,\n        }\n    }\n}\n", "211": "\nstruct WordDictionary {\n    words: Vec<String>,\n}\n\nimpl WordDictionary {\n    fn new() -> Self {\n        Self {\n            words: Vec::new(),\n        }\n    }\n\n    fn add_word(&self, word: String) {\n        self.words.push(word);\n    }\n\n    fn search(&self, word: String) -> bool {\n        for w in &self.words {\n            if w.contains(&word) {\n                return true;\n            }\n        }\n        false\n    }\n}\n", "212": "\nimpl Solution {\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\n        let mut result = Vec::new();\n\n        for word in words {\n            let mut found = false;\n            for i in 0..board.len() {\n                for j in 0..board[i].len() {\n                    if board[i][j] == word.chars().next().unwrap() {\n                        found = true;\n                        break;\n                    }\n                }\n                if found {\n                    break;\n                }\n            }\n            if found {\n                result.push(word);\n            }\n        }\n\n        result\n    }\n}\n", "17": "\nimpl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        let mut result = Vec::new();\n        if digits.is_empty() {\n            return result;\n        }\n        let mut current = String::new();\n        for digit in digits.chars() {\n            match digit {\n                '2' => current.push_str(\"abc\"),\n                '3' => current.push_str(\"def\"),\n                '4' => current.push_str(\"ghi\"),\n                '5' => current.push_str(\"jkl\"),\n                '6' => current.push_str(\"mno\"),\n                '7' => current.push_str(\"pqrs\"),\n                '8' => current.push_str(\"tuv\"),\n                '9' => current.push_str(\"wxyz\"),\n                _ => (),\n            }\n            if current.is_empty() {\n                continue;\n            }\n            result.push(current.clone());\n            current.clear();\n        }\n        result\n    }\n}\n", "77": "\nimpl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut current = Vec::new();\n        for i in 1..=n {\n            current.push(i);\n            if current.len() == k {\n                result.push(current.clone());\n                current.pop();\n            }\n        }\n        result\n    }\n}\n", "46": "\nimpl Solution {\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        Self::permute_helper(&nums, &mut result, 0);\n        result\n    }\n\n    fn permute_helper(nums: &[i32], result: &mut Vec<Vec<i32>>, start: usize) {\n        if start == nums.len() {\n            result.push(nums.to_vec());\n            return;\n        }\n\n        for i in start..nums.len() {\n            nums.swap(start, i);\n            Self::permute_helper(nums, result, start + 1);\n            nums.swap(start, i);\n        }\n    }\n}\n", "39": "\nimpl Solution {\n    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let mut combinations = Vec::new();\n        let mut current_combination = Vec::new();\n        let mut current_sum = 0;\n\n        for &candidate in candidates.iter() {\n            current_combination.push(candidate);\n            current_sum += candidate;\n\n            if current_sum == target {\n                combinations.push(current_combination.clone());\n            } else if current_sum > target {\n                current_combination.pop();\n                current_sum -= candidate;\n            }\n        }\n\n        combinations\n    }\n}\n", "52": "\nimpl Solution {\n    pub fn total_n_queens(n: i32) -> i32 {\n        let mut solutions = 0;\n        let mut board = vec![vec![false; n as usize]; n as usize];\n\n        for row in 0..n {\n            for col in 0..n {\n                if !board[row][col] {\n                    board[row][col] = true;\n                    solutions += 1;\n                    for i in 0..n {\n                        if i != row && board[i][col] {\n                            solutions -= 1;\n                            board[i][col] = false;\n                        }\n                    }\n                    for j in 0..n {\n                        if j != col && board[row][j] {\n                            solutions -= 1;\n                            board[row][j] = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        solutions\n    }\n}\n", "22": "\nimpl Solution {\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\n        let mut result = Vec::new();\n        let mut stack = Vec::new();\n\n        for _ in 0..n {\n            stack.push('(');\n        }\n\n        while !stack.is_empty() {\n            let mut s = String::new();\n            while let Some(c) = stack.pop() {\n                s.push(c);\n            }\n            result.push(s);\n        }\n\n        result\n    }\n}\n", "79": "\nimpl Solution {\n    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n        let m = board.len();\n        let n = board[0].len();\n        let word_len = word.len();\n\n        // Initialize a 2D array to keep track of visited cells\n        let mut visited = vec![vec![false; n]; m];\n\n        // Iterate over each row and column of the board\n        for i in 0..m {\n            for j in 0..n {\n                // If the current cell contains the first letter of the word,\n                // recursively search for the rest of the word in the same row\n                if board[i][j] == word[0] {\n                    if self.exist_helper(board, i, j, word, 1, &mut visited) {\n                        return true;\n                    }\n                }\n\n                // If the current cell contains the first letter of the word,\n                // recursively search for the rest of the word in the same column\n                if board[i][j] == word[0] {\n                    if self.exist_helper(board, i, j, word, 1, &mut visited) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        false\n    }\n\n    // Helper function to recursively search for the word in the board\n    fn exist_helper(\n        &self,\n        board: &Vec<Vec<char>>,\n        i: usize,\n        j: usize,\n        word: &str,\n        index: usize,\n        visited: &mut Vec<Vec<bool>>,\n    ) -> bool {\n        // If we have reached the end of the word, return true\n        if index == word.len() {\n            return true;\n        }\n\n        // If the current cell is out of bounds or has already been visited, return false\n        if i < 0 || i >= board.len() || j < 0 || j >= board[0].len() || visited[i][j] {\n            return false;\n        }\n\n        // If", "108": "\nfrom typing import List\n\nclass Solution:\n    def sorted_array_to_bst(self, nums: List[int]) -> TreeNode:\n        if not nums:\n            return None\n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sorted_array_to_bst(nums[:mid])\n        root.right = self.sorted_array_to_bst(nums[mid+1:])\n        return root\n", "148": "\nuse std::option::Option;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut head = head;\n        let mut sorted_head = None;\n\n        while let Some(node) = head {\n            head = node.next;\n            sorted_head = Some(node);\n        }\n\n        sorted_head\n    }\n}\n", "427": "\nuse std::collections::HashMap;\n\nstruct Node {\n    val: bool,\n    is_leaf: bool,\n    top_left: Option<Box<Node>>,\n    top_right: Option<Box<Node>>,\n    bottom_left: Option<Box<Node>>,\n    bottom_right: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(val: bool, is_leaf: bool) -> Self {\n        Self {\n            val,\n            is_leaf,\n            top_left: None,\n            top_right: None,\n            bottom_left: None,\n            bottom_right: None,\n        }\n    }\n}\n\nstruct Solution {\n    grid: Vec<Vec<bool>>,\n    nodes: HashMap<(usize, usize), Box<Node>>,\n}\n\nimpl Solution {\n    fn construct(grid: Vec<Vec<bool>>) -> Box<Node> {\n        let mut nodes = HashMap::new();\n        let mut root = None;\n\n        for i in 0..grid.len() {\n            for j in 0..grid[i].len() {\n                let node = Node::new(grid[i][j], false);\n                nodes.insert((i, j), Box::new(node));\n            }\n        }\n\n        for i in 0..grid.len() {\n            for j in 0..grid[i].len() {\n                let node = nodes.get(&(i, j)).unwrap();\n                if i > 0 {\n                    let top_left = nodes.get(&(i - 1, j)).unwrap();\n                    node.top_left = Some(top_left.clone());\n                }\n                if i < grid.len() - 1 {\n                    let top_right = nodes.get(&(i + 1, j)).unwrap();\n                    node.top_right = Some(top_right.clone());\n                }\n                if j > 0 {\n                    let bottom_left = nodes.get(&(i, j - 1)).unwrap();\n                    node.bottom_left = Some(", "23": "\ndef merge_k_lists(lists):\n    if not lists:\n        return []\n    return sorted(sum(lists, []))\n", "53": "\nimpl Solution {\n    pub fn max_sub_array(nums: Vec<i32>) -> i32 {\n        let mut max_sum = 0;\n        let mut current_sum = 0;\n\n        for num in nums {\n            current_sum += num;\n            if current_sum > max_sum {\n                max_sum = current_sum;\n            }\n            if current_sum < 0 {\n                current_sum = 0;\n            }\n        }\n\n        max_sum\n    }\n}\n", "918": "\nimpl Solution {\n    pub fn max_subarray_sum_circular(nums: Vec<i32>) -> i32 {\n        let mut max_sum = 0;\n        let mut current_sum = 0;\n        let mut start_index = 0;\n        let mut end_index = 0;\n\n        for i in 0..nums.len() {\n            current_sum += nums[i];\n            if current_sum > max_sum {\n                max_sum = current_sum;\n                start_index = i - (current_sum - max_sum);\n                end_index = i;\n            }\n        }\n\n        return max_sum;\n    }\n}\n", "35": "\nimpl Solution {\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n\n        while left <= right {\n            let mid = (left + right) / 2;\n            if nums[mid] == target {\n                return mid as i32;\n            } else if nums[mid] < target {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left as i32;\n    }\n}\n", "74": "\nimpl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        let m = matrix.len();\n        let n = matrix[0].len();\n\n        let mut left = 0;\n        let mut right = m * n - 1;\n\n        while left <= right {\n            let mid = (left + right) / 2;\n            let row = mid / n;\n            let col = mid % n;\n\n            if matrix[row][col] == target {\n                return true;\n            } else if matrix[row][col] > target {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        false\n    }\n}\n", "162": "\nimpl Solution {\n    pub fn find_peak_element(nums: Vec<i32>) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n\n        while left < right {\n            let mid = (left + right) / 2;\n            if nums[mid] > nums[mid + 1] {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        if nums[left] > nums[right] {\n            left\n        } else {\n            right\n        }\n    }\n}\n", "33": "\nimpl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n\n        while left <= right {\n            let mid = (left + right) / 2;\n            if nums[mid] == target {\n                return mid as i32;\n            }\n\n            if nums[mid] < target {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        -1\n    }\n}\n", "34": "\nimpl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n\n        while left <= right {\n            let mid = (left + right) / 2;\n            if nums[mid] == target {\n                // Found the target, now find the starting and ending indices\n                let mut start = mid;\n                while start > 0 && nums[start - 1] == target {\n                    start -= 1;\n                }\n                let mut end = mid;\n                while end < nums.len() - 1 && nums[end + 1] == target {\n                    end += 1;\n                }\n                return vec![start as i32, end as i32];\n            } else if nums[mid] < target {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        // Target not found\n        return vec![-1, -1];\n    }\n}\n", "153": "\nimpl Solution {\n    pub fn find_min(nums: Vec<i32>) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n\n        while left < right {\n            let mid = (left + right) / 2;\n            if nums[mid] < nums[right] {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        nums[left]\n    }\n}\n", "4": "\nimpl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        let (mut m, mut n) = (nums1.len(), nums2.len());\n        let (mut i, mut j) = (0, 0);\n        let (mut max_left, mut min_right) = (0, 0);\n\n        while i < m && j < n {\n            if nums1[i] <= nums2[j] {\n                max_left = nums1[i];\n                i += 1;\n            } else {\n                max_left = nums2[j];\n                j += 1;\n            }\n        }\n\n        if i < m {\n            min_right = nums1[i];\n        } else {\n            min_right = nums2[j];\n        }\n\n        let (median, _) = if m + n % 2 == 0 {\n            (max_left + min_right) / 2.0, true)\n        } else {\n            (max_left, false)\n        };\n\n        median\n    }\n}\n", "215": "\nimpl Solution {\n    pub fn find_kth_largest(nums: Vec<i32>, k: i32) -> i32 {\n        let mut nums = nums;\n        let mut k = k;\n\n        nums.sort_by(|a, b| b.cmp(a));\n\n        if k > nums.len() as i32 {\n            return nums[0];\n        }\n\n        nums[k as usize - 1]\n    }\n}\n", "502": "\nimpl Solution {\n    pub fn find_maximized_capital(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {\n        let mut max_capital = 0;\n        let mut current_capital = w;\n        let mut projects = Vec::new();\n\n        for i in 0..profits.len() {\n            if current_capital >= capital[i] {\n                projects.push((profits[i], capital[i]));\n                current_capital -= capital[i];\n            }\n        }\n\n        projects.sort_by(|a, b| b.0.cmp(&a.0));\n\n        for i in 0..k {\n            if i < projects.len() {\n                max_capital += projects[i].0;\n                current_capital += projects[i].1;\n            }\n        }\n\n        max_capital + current_capital\n    }\n}\n", "373": "\nimpl Solution {\n    pub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\n        let mut pairs = Vec::new();\n        let mut i = 0;\n        let mut j = 0;\n        let mut sum = 0;\n\n        while i < nums1.len() && j < nums2.len() && k > 0 {\n            sum = nums1[i] + nums2[j];\n            pairs.push(vec![nums1[i], nums2[j]]);\n            i += 1;\n            j += 1;\n            k -= 1;\n        }\n\n        pairs\n    }\n}\n", "295": "\nstruct MedianFinder {\n    nums: Vec<i32>,\n}\n\nimpl MedianFinder {\n    fn new() -> Self {\n        MedianFinder {\n            nums: Vec::new(),\n        }\n    }\n\n    fn add_num(&self, num: i32) {\n        self.nums.push(num);\n    }\n\n    fn find_median(&self) -> f64 {\n        let len = self.nums.len();\n        if len == 0 {\n            return 0.0;\n        }\n\n        let mid = len / 2;\n        if len % 2 == 0 {\n            return (self.nums[mid - 1] + self.nums[mid]) as f64 / 2.0;\n        }\n\n        return self.nums[mid] as f64;\n    }\n}\n", "67": "\nimpl Solution {\n    pub fn add_binary(a: String, b: String) -> String {\n        let mut result = String::new();\n        let mut carry = 0;\n\n        for i in 0..a.len().max(b.len()) {\n            let a_digit = a.chars().nth(i).unwrap_or('0');\n            let b_digit = b.chars().nth(i).unwrap_or('0');\n\n            let sum = (a_digit.to_digit(10).unwrap() + b_digit.to_digit(10).unwrap() + carry) % 2;\n            result.push(sum.to_string());\n\n            carry = (a_digit.to_digit(10).unwrap() + b_digit.to_digit(10).unwrap() + carry) / 2;\n        }\n\n        if carry > 0 {\n            result.push(carry.to_string());\n        }\n\n        result\n    }\n}\n", "190": "\nfn reverse_bits(x: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..32 {\n        result |= (x & (1 << i)) >> (31 - i);\n    }\n    result\n}\n", "191": "\nfn hamming_weight(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 0..32 {\n        if n & (1 << i) != 0 {\n            count += 1;\n        }\n    }\n    count\n}\n", "136": "\nimpl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        let mut seen = HashSet::new();\n        for num in nums {\n            if seen.contains(&num) {\n                seen.remove(&num);\n            } else {\n                seen.insert(num);\n            }\n        }\n        *seen.iter().next().unwrap()\n    }\n}\n", "137": "\nimpl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        let mut seen = HashSet::new();\n        for num in nums {\n            if seen.contains(&num) {\n                seen.remove(&num);\n            } else {\n                seen.insert(num);\n            }\n        }\n        *seen.iter().next().unwrap()\n    }\n}\n", "201": "\nimpl Solution {\n    pub fn range_bitwise_and(left: i32, right: i32) -> i32 {\n        let mut result = 0;\n        for i in left..=right {\n            result |= i;\n        }\n        result\n    }\n}\n", "9": "\nimpl Solution {\n    pub fn is_palindrome(x: i32) -> bool {\n        let mut digits = Vec::new();\n        let mut x = x;\n        while x > 0 {\n            digits.push(x % 10);\n            x /= 10;\n        }\n        for i in 0..digits.len() / 2 {\n            if digits[i] != digits[digits.len() - i - 1] {\n                return false;\n            }\n        }\n        true\n    }\n}\n", "66": "\nimpl Solution {\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut carry = 1;\n\n        for digit in digits.iter().rev() {\n            let sum = carry + *digit;\n            carry = sum / 10;\n            result.push(sum % 10);\n        }\n\n        if carry > 0 {\n            result.push(carry);\n        }\n\n        result.reverse();\n        result\n    }\n}\n", "172": "\nimpl Solution {\n    pub fn trailing_zeroes(n: i32) -> i32 {\n        let mut count = 0;\n        let mut i = 5;\n        while i <= n {\n            count += n / i;\n            i *= 5;\n        }\n        count\n    }\n}\n", "69": "\nimpl Solution {\n    pub fn my_sqrt(x: i32) -> i32 {\n        let mut result = 0;\n        let mut i = 1;\n        while i * i <= x {\n            result = i;\n            i += 1;\n        }\n        result\n    }\n}\n", "50": "\nimpl Solution {\n    pub fn my_pow(x: f64, n: i32) -> f64 {\n        if n == 0 {\n            return 1.0;\n        }\n        if n < 0 {\n            return 1.0 / my_pow(x, -n);\n        }\n        return x * my_pow(x, n - 1);\n    }\n}\n", "149": "\nimpl Solution {\n    pub fn max_points(points: Vec<Vec<i32>>) -> i32 {\n        let mut max_points = 0;\n        let mut seen = HashSet::new();\n\n        for i in 0..points.len() {\n            let mut slope = 0;\n            let mut count = 1;\n\n            for j in (i + 1)..points.len() {\n                let x1 = points[i][0];\n                let y1 = points[i][1];\n                let x2 = points[j][0];\n                let y2 = points[j][1];\n\n                if x1 == x2 && y1 == y2 {\n                    count += 1;\n                } else {\n                    let slope = (y2 - y1) as f64 / (x2 - x1) as f64;\n                    if seen.contains(&slope) {\n                        count += seen[&slope];\n                    } else {\n                        seen.insert(slope, count);\n                    }\n                }\n            }\n\n            max_points = max(max_points, count);\n        }\n\n        max_points\n    }\n}\n", "70": "\nimpl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        if n == 1 {\n            return 1;\n        }\n        if n == 2 {\n            return 2;\n        }\n        return Solution::climb_stairs(n - 1) + Solution::climb_stairs(n - 2);\n    }\n}\n", "198": "\nimpl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        let mut dp = vec![0; nums.len()];\n        dp[0] = nums[0];\n        for i in 1..nums.len() {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n        dp[nums.len() - 1]\n    }\n}\n", "139": "\nimpl Solution {\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\n        let mut dp = vec![false; s.len() + 1];\n        dp[0] = true;\n\n        for i in 1..=s.len() {\n            for j in 1..=i {\n                if dp[j - 1] && word_dict.contains(&s[j - 1..i]) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        dp[s.len()]\n    }\n}\n", "322": "\nimpl Solution {\n    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n        // Initialize the dp array with the maximum value\n        let mut dp = vec![amount as i32; amount as usize + 1];\n        dp[0] = 0;\n\n        // Loop through the coins and update the dp array\n        for i in 1..=amount {\n            for j in 0..coins.len() {\n                if i - coins[j] >= 0 && dp[i - coins[j]] + 1 < dp[i] {\n                    dp[i] = dp[i - coins[j]] + 1;\n                }\n            }\n        }\n\n        // Return the fewest number of coins that can be used to make up the amount\n        if dp[amount] == amount {\n            -1\n        } else {\n            dp[amount]\n        }\n    }\n}\n", "300": "\nimpl Solution {\n    pub fn length_of_lis(nums: Vec<i32>) -> i32 {\n        let mut dp = vec![1; nums.len()];\n        let mut max_len = 1;\n\n        for i in 1..nums.len() {\n            for j in 0..i {\n                if nums[i] > nums[j] && dp[i] < dp[j] + 1 {\n                    dp[i] = dp[j] + 1;\n                    max_len = max(max_len, dp[i]);\n                }\n            }\n        }\n\n        max_len\n    }\n}\n", "120": "\nimpl Solution {\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n        let mut min_sum = 0;\n        let mut current_row = 0;\n        let mut current_sum = 0;\n\n        while current_row < triangle.len() {\n            let mut next_row = current_row + 1;\n            let mut next_sum = 0;\n\n            while next_row < triangle.len() {\n                let mut sum = 0;\n                for i in 0..triangle[next_row].len() {\n                    sum += triangle[next_row][i];\n                }\n                if sum < next_sum {\n                    next_sum = sum;\n                }\n                next_row += 1;\n            }\n\n            if next_sum < current_sum {\n                current_sum = next_sum;\n            }\n            current_row += 1;\n        }\n\n        return current_sum;\n    }\n}\n", "64": "\nimpl Solution {\n    pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {\n        let m = grid.len();\n        let n = grid[0].len();\n\n        let mut dp = vec![vec![0; n]; m];\n\n        for i in 0..m {\n            for j in 0..n {\n                if i == 0 && j == 0 {\n                    dp[i][j] = grid[i][j];\n                } else if i == 0 {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n                } else if j == 0 {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                } else {\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n                }\n            }\n        }\n\n        dp[m - 1][n - 1]\n    }\n}\n", "63": "\nimpl Solution {\n    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        let m = obstacle_grid.len();\n        let n = obstacle_grid[0].len();\n        let mut dp = vec![vec![0; n]; m];\n        dp[0][0] = 1;\n\n        for i in 0..m {\n            for j in 0..n {\n                if obstacle_grid[i][j] == 1 {\n                    dp[i][j] = 0;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n\n        dp[m - 1][n - 1]\n    }\n}\n", "5": "\nimpl Solution {\n    pub fn longest_palindrome(s: String) -> String {\n        let mut longest_palindrome = String::new();\n        let mut current_palindrome = String::new();\n\n        for i in 0..s.len() {\n            current_palindrome.clear();\n            current_palindrome.push(s[i]);\n\n            for j in i+1..s.len() {\n                if s[i] == s[j] && current_palindrome.len() < 2 {\n                    current_palindrome.push(s[j]);\n                } else if s[i] == s[j] && current_palindrome.len() == 2 {\n                    if current_palindrome.len() > longest_palindrome.len() {\n                        longest_palindrome = current_palindrome.clone();\n                    }\n                    current_palindrome.clear();\n                    current_palindrome.push(s[i]);\n                }\n            }\n\n            if current_palindrome.len() > longest_palindrome.len() {\n                longest_palindrome = current_palindrome.clone();\n            }\n        }\n\n        longest_palindrome\n    }\n}\n", "97": "\nimpl Solution {\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        let s1 = s1.as_str();\n        let s2 = s2.as_str();\n        let s3 = s3.as_str();\n\n        let mut s1_idx = 0;\n        let mut s2_idx = 0;\n        let mut s3_idx = 0;\n\n        while s1_idx < s1.len() && s2_idx < s2.len() && s3_idx < s3.len() {\n            if s1[s1_idx] == s3[s3_idx] {\n                s1_idx += 1;\n            }\n            if s2[s2_idx] == s3[s3_idx] {\n                s2_idx += 1;\n            }\n            s3_idx += 1;\n        }\n\n        s1_idx == s1.len() && s2_idx == s2.len() && s3_idx == s3.len()\n    }\n}\n", "72": "\nimpl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        let mut dp = vec![vec![0; word2.len() + 1]; word1.len() + 1];\n\n        for i in 0..=word1.len() {\n            dp[i][0] = i as i32;\n        }\n\n        for j in 0..=word2.len() {\n            dp[0][j] = j as i32;\n        }\n\n        for i in 1..=word1.len() {\n            for j in 1..=word2.len() {\n                let cost = if word1.chars().nth(i - 1) == word2.chars().nth(j - 1) {\n                    0\n                } else {\n                    1\n                };\n\n                dp[i][j] = std::cmp::min(\n                    dp[i - 1][j - 1] + cost,\n                    std::cmp::min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),\n                );\n            }\n        }\n\n        dp[word1.len()][word2.len()]\n    }\n}\n", "123": "\nimpl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut max_profit = 0;\n        let mut buy_price = None;\n        let mut sell_price = None;\n\n        for price in prices {\n            if buy_price.is_none() && price < sell_price {\n                buy_price = Some(price);\n            } else if sell_price.is_none() && price > buy_price {\n                sell_price = Some(price);\n            }\n\n            if buy_price.is_some() && sell_price.is_some() {\n                max_profit = max(max_profit, sell_price.unwrap() - buy_price.unwrap());\n                buy_price = None;\n                sell_price = None;\n            }\n        }\n\n        max_profit\n    }\n}\n", "188": "\nimpl Solution {\n    pub fn max_profit(k: i32, prices: Vec<i32>) -> i32 {\n        let mut max_profit = 0;\n        let mut buy_prices = Vec::new();\n        let mut sell_prices = Vec::new();\n\n        for i in 0..prices.len() {\n            if i < k {\n                buy_prices.push(prices[i]);\n            } else {\n                sell_prices.push(prices[i]);\n            }\n        }\n\n        for i in 0..k {\n            max_profit += sell_prices[i] - buy_prices[i];\n        }\n\n        max_profit\n    }\n}\n", "221": "\nimpl Solution {\n    pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\n        let mut max_area = 0;\n        for i in 0..matrix.len() {\n            for j in 0..matrix[i].len() {\n                if matrix[i][j] == '1' {\n                    let mut area = 1;\n                    for k in 0..matrix.len() {\n                        if matrix[i + k][j + k] == '1' {\n                            area += 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    max_area = max(max_area, area);\n                }\n            }\n        }\n        max_area\n    }\n}\n"}