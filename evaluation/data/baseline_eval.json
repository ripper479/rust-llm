{"88": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 22: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 8 | if nums1[i] <= nums2[j] { | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 8: Char 34: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 8 | if nums1[i] <= nums2[j] { | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 9: Char 34: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 9 | nums1[k] = nums1[i]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 12: Char 34: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 12 | nums1[k] = nums2[j]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 19: Char 30: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 19 | nums1[k] = nums1[i]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 25: Char 30: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 25 | nums1[k] = nums2[j]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 6 previous errors"}, "27": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 9: error: mismatched types (solution.rs) | 2 | pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 { | --- expected `i32` because of return type ... 10 | k | ^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 10 | k.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "26": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 35: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut unique_elements = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 21+ use std::collections::HashSet; | Line 9: Char 27: error: mismatched types (solution.rs) | 9 | nums[k] = num; | ------- ^^^ expected `i32`, found `&mut i32` | | | expected due to the type of this binding | help: consider dereferencing the borrow | 9 | nums[k] = *num; | + Line 14: Char 9: error: mismatched types (solution.rs) | 2 | pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 14 | k | ^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 14 | k.try_into().unwrap() | ++++++++++++++++++++ Some errors have detailed explanations: E0308, E0433. For more information about an error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "80": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 22: Char 9: error: mismatched types (solution.rs) | 2 | pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 22 | i + 1 | ^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 22 | (i + 1).try_into().unwrap() | + +++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "169": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "189": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "121": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "122": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "55": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "45": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "274": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 35: error: failed to resolve: use of undeclared type `HashMap` (solution.rs) | 3 | let mut citation_counts = HashMap::new(); | ^^^^^^^ use of undeclared type `HashMap` | help: consider importing this struct | 21+ use std::collections::HashMap; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "380": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 2: Char 10: error: cannot find type `HashSet` in this scope (solution.rs) | 2 | set: HashSet<i32>, | ^^^^^^^ not found in this scope | help: consider importing this struct | 48+ use std::collections::HashSet; | Line 3: Char 10: error: cannot find type `StdRng` in this scope (solution.rs) | 3 | rng: StdRng, | ^^^^^^ --> /rustc/a28077b28a02b92985b3a3faecf92813155f1ea1/library/alloc/src/string.rs:365:1 | = note: similarly named struct `String` defined here | help: a struct with a similar name exists | 3 | rng: String, | ~~~~~~ help: consider importing this struct | 48+ use rand::rngs::StdRng; | Line 9: Char 18: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 9 | set: HashSet::new(), | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 48 + use std::collections::HashSet; | Line 10: Char 18: error: failed to resolve: use of undeclared type `StdRng` (solution.rs) | 10 | rng: StdRng::from_seed(rand::thread_rng().gen()), | ^^^^^^ use of undeclared type `StdRng` | help: a struct with a similar name exists | 10 | rng: String::from_seed(rand::thread_rng().gen()), | ~~~~~~ help: consider importing this struct | 48 + use rand::rngs::StdRng; | Line 10: Char 55: error: no method named `gen` found for struct `ThreadRng` in the current scope (solution.rs) | 10 | rng: StdRng::from_seed(rand::thread_rng().gen()), | ^^^ method not found in `ThreadRng` | ::: /usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/rand-0.8.5/src/rng.rs:93:8 | 92 | fn gen<T>(&mut self) -> T | --- the method is available for `ThreadRng` here | = help: items from traits can only be used if the trait is in scope help: the following trait is implemented but not in scope; perhaps add a `use` for it: | 2 + use rand::Rng; | Some errors have detailed explanations: E0412, E0433, E0599. For more information about an error, try `rustc --explain E0412`. error: could not compile `prog` (bin \"prog\") due to 5 previous errors"}, "238": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "134": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 20: Char 9: error: mismatched types (solution.rs) | 2 | pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 20 | start_index | ^^^^^^^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 20 | start_index.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "135": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "42": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "13": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "12": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "58": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "14": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "151": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "6": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "28": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 7: Char 34: error: no method named `len` found for struct `Chars` in the current scope (solution.rs) | 7 | while i < haystack_chars.len() && j < needle_chars.len() { | ^^^ method not found in `Chars<'_>` Line 7: Char 60: error: no method named `len` found for struct `Chars` in the current scope (solution.rs) | 7 | while i < haystack_chars.len() && j < needle_chars.len() { | ^^^ method not found in `Chars<'_>` Line 8: Char 30: error: cannot index into a value of type `Chars<'_>` (solution.rs) | 8 | if haystack_chars[i] == needle_chars[j] { | ^^^ Line 8: Char 49: error: cannot index into a value of type `Chars<'_>` (solution.rs) | 8 | if haystack_chars[i] == needle_chars[j] { | ^^^ Line 15: Char 30: error: no method named `len` found for struct `Chars` in the current scope (solution.rs) | 15 | if j == needle_chars.len() { | ^^^ method not found in `Chars<'_>` Some errors have detailed explanations: E0599, E0608. For more information about an error, try `rustc --explain E0599`. error: could not compile `prog` (bin \"prog\") due to 5 previous errors"}, "68": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 45: error: mismatched types (solution.rs) | 8 | if current_width + word.len() > max_width { | -------------------------- ^^^^^^^^^ expected `usize`, found `i32` | | | expected because this is `usize` | help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit | 8 | if current_width + word.len() > max_width.try_into().unwrap() { | ++++++++++++++++++++ Line 14: Char 35: error: mismatched types (solution.rs) | 14 | current_line.push_str(word); | -------- ^^^^ expected `&str`, found `String` | | | arguments to this method are incorrect | Line 901: Char 12: note: method defined here (solution.rs) help: consider borrowing here | 14 | current_line.push_str(&word); | + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "125": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "392": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 16: error: cannot borrow `s_chars` as mutable, as it is not declared as mutable (solution.rs) | 8 | if s_chars.nth(window_start) == Some(t_char) { | ^^^^^^^ cannot borrow as mutable | help: consider changing this to be mutable | 3 | let mut s_chars = s.chars(); | +++ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "167": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 9: Char 29: error: mismatched types (solution.rs) | 9 | return vec![left + 1, right + 1]; | ^^^^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 9 | return vec![(left + 1).try_into().unwrap(), right + 1]; | + +++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "11": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "15": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "209": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 20: Char 13: error: mismatched types (solution.rs) | 2 | pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 20 | min_len | ^^^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 20 | min_len.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "3": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 32: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 8 | let current_char = s[end]; | ^^^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 16: Char 9: error: mismatched types (solution.rs) | 2 | pub fn length_of_longest_substring(s: String) -> i32 { | --- expected `i32` because of return type ... 16 | longest_substring | ^^^^^^^^^^^^^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 16 | longest_substring.try_into().unwrap() | ++++++++++++++++++++ Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "30": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 38: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 10 | while k < s.len() && s[k] == word[0] { | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 10: Char 46: error: the type `std::string::String` cannot be indexed by `{integer}` (solution.rs) | 10 | while k < s.len() && s[k] == word[0] { | ^^^^^^^ `std::string::String` cannot be indexed by `{integer}` | = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "76": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 17: error: borrow of moved value: `window` (solution.rs) | 5 | let mut window = Vec::new(); | ---------- move occurs because `window` has type `Vec<u8>`, which does not implement the `Copy` trait ... 11 | while i < s.len() { | ----------------- inside of this loop 12 | if s[i] == t[j] { 13 | window.push(s[i]); | ^^^^^^ value borrowed here after move ... 17 | min_window = window; | ------ value moved here, in previous iteration of loop | help: consider cloning the value if the performance cost is acceptable | 17 | min_window = window.clone(); | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "36": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 5: Char 28: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 5 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 56+ use std::collections::HashSet; | Line 19: Char 28: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 19 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 56 + use std::collections::HashSet; | Line 34: Char 32: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 34 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 56 + use std::collections::HashSet; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "54": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 22: Char 47: index out of bounds: the len is 1 but the index is 18446744073709551615 (solution.rs)"}, "48": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "73": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "289": {"compiled": "false", "verdict": "Context-Length Exceeded", "stderr": "Context-Length Exceeded"}, "383": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "205": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 25: error: failed to resolve: use of undeclared type `HashMap` (solution.rs) | 3 | let mut s_map = HashMap::new(); | ^^^^^^^ use of undeclared type `HashMap` | help: consider importing this struct | 33+ use std::collections::HashMap; | Line 4: Char 25: error: failed to resolve: use of undeclared type `HashMap` (solution.rs) | 4 | let mut t_map = HashMap::new(); | ^^^^^^^ use of undeclared type `HashMap` | help: consider importing this struct | 33+ use std::collections::HashMap; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "290": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "242": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "49": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 12: Char 32: error: can't compare `std::string::String` with `char` (solution.rs) | 12 | if anagrams[i] == anagram { | ^^ no implementation for `std::string::String == char` | = help: the trait `PartialEq<char>` is not implemented for `std::string::String` = help: the following other types implement trait `PartialEq<Rhs>`: <std::string::String as PartialEq<Cow<'a, str>>> <std::string::String as PartialEq<Value>> <std::string::String as PartialEq> <std::string::String as PartialEq<str>> <std::string::String as PartialEq<&'a str>> = note: required for `Vec<std::string::String>` to implement `PartialEq<Vec<char>>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "1": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "202": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 24: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 27+ use std::collections::HashSet; | Line 20: Char 9: error: mismatched types (solution.rs) | 15 | fn sum_of_squares(n: i32) -> i32 { | --- expected `i32` because of return type ... 20 | sum | ^^^ expected `i32`, found `u32` | help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit | 20 | sum.try_into().unwrap() | ++++++++++++++++++++ Some errors have detailed explanations: E0308, E0433. For more information about an error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "219": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 24: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 20+ use std::collections::HashSet; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "128": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 4: Char 24: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 4 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 30+ use std::collections::HashSet; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "228": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "56": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 17: Char 40: error: cannot find function `max` in this scope (solution.rs) | 17 | last_interval[1] = max(last_end, end); | ^^^ not found in this scope | help: consider importing one of these items | 31 + use core::cmp::max; | 31 + use std::cmp::max; | For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "57": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 35: error: cannot find function `min` in this scope (solution.rs) | 10 | new_interval[0] = min(new_interval[0], intervals[i][0]); | ^^^ ... 45 | fn main() { | --------- similarly named function `main` defined here | help: a function with a similar name exists | 10 | new_interval[0] = main(new_interval[0], intervals[i][0]); | ~~~~ help: consider importing one of these items | 28 + use core::cmp::min; | 28 + use std::cmp::min; | Line 11: Char 35: error: cannot find function `max` in this scope (solution.rs) | 11 | new_interval[1] = max(new_interval[1], intervals[i][1]); | ^^^ not found in this scope | help: consider importing one of these items | 28 + use core::cmp::max; | 28 + use std::cmp::max; | For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "452": {"compiled": "false", "verdict": "Context-Length Exceeded", "stderr": "Context-Length Exceeded"}, "20": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "71": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 29: error: expected `;`, found `stack` (solution.rs) | 3 | tokens = path.split(\"/\") | ^ help: add `;` here 4 | stack = [] | ----- unexpected token Line 4: Char 15: error: expected `;`, found keyword `for` (solution.rs) | 4 | stack = [] | ^ help: add `;` here 5 | for token in tokens: | --- unexpected token Line 5: Char 24: error: expected `{`, found `:` (solution.rs) | 5 | for token in tokens: | ^ expected `{` error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "155": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 16: Char 47: error: mismatched types (solution.rs) | 16 | if self.min_stack.is_empty() || val < self.min_stack.last().unwrap() { | --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32` | | | expected because this is `i32` | help: consider dereferencing the borrow | 16 | if self.min_stack.is_empty() || val < *self.min_stack.last().unwrap() { | + Line 19: Char 33: error: mismatched types (solution.rs) | 19 | self.min_stack.push(self.min_stack.last().unwrap()); | ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32` | | | arguments to this method are incorrect | Line 1877: Char 12: note: method defined here (solution.rs) help: consider dereferencing the borrow | 19 | self.min_stack.push(*self.min_stack.last().unwrap()); | + Line 29: Char 9: error: mismatched types (solution.rs) | 28 | fn top(&self) -> i32 { | --- expected `i32` because of return type 29 | self.stack.last().unwrap() | ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32` | help: consider dereferencing the borrow | 29 | *self.stack.last().unwrap() | + Line 33: Char 9: error: mismatched types (solution.rs) | 32 | fn get_min(&self) -> i32 { | --- expected `i32` because of return type 33 | self.min_stack.last().unwrap() | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32` | help: consider dereferencing the borrow | 33 | *self.min_stack.last().unwrap() | + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "150": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "224": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 38: Char 9: error: mismatched types (solution.rs) | 2 | pub fn calculate(s: String) -> i32 { | --- expected `i32` because of return type ... 38 | result | ^^^^^^ expected `i32`, found `u32` | help: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit | 38 | result.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "141": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "2": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "21": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 19: Char 28: error: expected `;`, found `tail` (solution.rs) | 19 | dummy = ListNode(0) | ^ help: add `;` here 20 | tail = dummy | ---- unexpected token Line 20: Char 21: error: expected `;`, found keyword `while` (solution.rs) | 20 | tail = dummy | ^ help: add `;` here 21 | while list1 and list2: | ----- unexpected token Line 21: Char 21: error: `and` is not a logical operator (solution.rs) | 21 | while list1 and list2: | ^^^ help: use `&&` to perform logical conjunction | = note: unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators Line 21: Char 30: error: expected `{`, found `:` (solution.rs) | 21 | while list1 and list2: | ----- ---------------^ expected `{` | | | | | this `while` condition successfully parsed | while parsing the body of this `while` expression error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "138": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "92": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 41: Char 29: error: mismatched types (solution.rs) | 41 | node.next = previous; | --------- ^^^^^^^^ expected `Option<Box<ListNode>>`, found `Box<ListNode>` | | | expected due to the type of this binding | = note: expected enum `Option<Box<_>>` found struct `Box<_>` help: try wrapping the expression in `Some` | 41 | node.next = Some(previous); | +++++ + Line 42: Char 28: error: mismatched types (solution.rs) | 34 | if let Some(previous) = previous { | -------- expected due to the type of this binding ... 42 | previous = Some(node); | ^^^^^^^^^^ expected `Box<ListNode>`, found `Option<Box<ListNode>>` | = note: expected struct `Box<_>` found enum `Option<Box<_>>` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "25": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 45: Char 18: error: no field `next` on type `Option<Box<list_node::ListNode>>` (solution.rs) | 45 | new_head.next = previous; | ^^^^ Line 55: Char 18: error: no field `next` on type `Option<Box<list_node::ListNode>>` (solution.rs) | 55 | new_tail.next = None; | ^^^^ For more information about this error, try `rustc --explain E0609`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "19": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 26: Char 31: error: no field `next` on type `Option<Box<list_node::ListNode>>` (solution.rs) | 26 | current = current.next; | ^^^^ Line 31: Char 28: error: no field `next` on type `Option<Box<list_node::ListNode>>` (solution.rs) | 31 | head = current.next; | ^^^^ Line 33: Char 46: error: no field `next` on type `Option<Box<list_node::ListNode>>` (solution.rs) | 33 | previous.unwrap().next = current.next; | ^^^^ For more information about this error, try `rustc --explain E0609`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "82": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 19: Char 16: error: unexpected `head` after identifier (solution.rs) | 19 | if not head: | ----^^^^ | | | help: use `!` to perform logical negation or bitwise not Line 19: Char 20: error: expected `{`, found `:` (solution.rs) | 19 | if not head: | ^ expected `{` | Line 19: Char 12: note: the `if` expression is missing a block after this condition (solution.rs) | 19 | if not head: | ^^^^^^^^ error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "61": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 35: Char 28: error: use of moved value: `head` (solution.rs) | 18 | pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { | ---- move occurs because `head` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait ... 24 | let mut current = head; | ---- value moved here ... 35 | let mut new_head = head; | ^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 24 | let mut current = head.clone(); | ++++++++ Line 40: Char 27: error: use of moved value: `head` (solution.rs) | 18 | pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { | ---- move occurs because `head` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait ... 35 | let mut new_head = head; | ---- value moved here ... 40 | let mut current = head; | ^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 35 | let mut new_head = head.clone(); | ++++++++ Line 43: Char 13: error: use of moved value: `current` (solution.rs) | 40 | let mut current = head; | ----------- move occurs because `current` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait 41 | while current.is_some() { | ----------------------- inside of this loop 42 | let next = current.unwrap().next; | ------- -------- `current` moved due to this method call | | | help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents 43 | current.unwrap().next = new_head; | ^^^^^^^ value used here after move | Line 931: Char 25: note: `Option::<T>::unwrap` takes ownership of the receiver `self`, which moves `current` (solution.rs) help: you can `clone` the value and consume it, but this might not be your desired behavior | 42 | let next = current.clone().unwrap().next; | ++++++++ Line 47: Char 9: error: use of moved value: `new_head` (solution.rs) | 35 | let mut new_head = head; | ------------ move occurs because `new_head` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait ... 41 | while current.is_some() { | ----------------------- inside of this loop 42 | let next = current.unwrap().next; 43 | current.unwrap().next = new_head; | -------- value moved here, in previous iteration of loop ... 47 | new_head | ^^^^^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 43 | current.unwrap().next = new_head.clone(); | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "86": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 31: Char 23: error: use of moved value: `node.next` (solution.rs) | 25 | while let Some(node) = current { | ---- move occurs because `node` has type `Box<list_node::ListNode>`, which does not implement the `Copy` trait 26 | if node.val < x { 27 | less_than_x.push(node); | ---- value moved here 28 | } else { 29 | greater_than_or_equal_to_x.push(node); | ---- value moved here 30 | } 31 | current = node.next; | ^^^^^^^^^ value used here after move For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "146": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 10: error: cannot find type `HashMap` in this scope (solution.rs) | 3 | map: HashMap<i32, i32>, | ^^^^^^^ not found in this scope | help: consider importing this struct | 40+ use std::collections::HashMap; | Line 4: Char 12: error: cannot find type `VecDeque` in this scope (solution.rs) | 4 | queue: VecDeque<i32>, | ^^^^^^^^ not found in this scope | help: consider importing this struct | 40+ use std::collections::VecDeque; | Line 11: Char 18: error: failed to resolve: use of undeclared type `HashMap` (solution.rs) | 11 | map: HashMap::new(), | ^^^^^^^ use of undeclared type `HashMap` | help: consider importing this struct | 40 + use std::collections::HashMap; | Line 12: Char 20: error: failed to resolve: use of undeclared type `VecDeque` (solution.rs) | 12 | queue: VecDeque::new(), | ^^^^^^^^ use of undeclared type `VecDeque` | help: consider importing this struct | 40 + use std::collections::VecDeque; | Some errors have detailed explanations: E0412, E0433. For more information about an error, try `rustc --explain E0412`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "104": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "100": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 31: Char 40: error: cannot move out of dereference of `Ref<'_, tree_node::TreeNode>` (solution.rs) | 31 | Solution::is_same_tree(p.borrow().left, q.borrow().left) && | ^^^^^^^^^^^^^^^ move occurs because value has type `Option<Rc<RefCell<tree_node::TreeNode>>>`, which does not implement the `Copy` trait Line 31: Char 57: error: cannot move out of dereference of `Ref<'_, tree_node::TreeNode>` (solution.rs) | 31 | Solution::is_same_tree(p.borrow().left, q.borrow().left) && | ^^^^^^^^^^^^^^^ move occurs because value has type `Option<Rc<RefCell<tree_node::TreeNode>>>`, which does not implement the `Copy` trait Line 32: Char 44: error: cannot move out of dereference of `Ref<'_, tree_node::TreeNode>` (solution.rs) | 32 | Solution::is_same_tree(p.borrow().right, q.borrow().right) | ^^^^^^^^^^^^^^^^ move occurs because value has type `Option<Rc<RefCell<tree_node::TreeNode>>>`, which does not implement the `Copy` trait Line 32: Char 62: error: cannot move out of dereference of `Ref<'_, tree_node::TreeNode>` (solution.rs) | 32 | Solution::is_same_tree(p.borrow().right, q.borrow().right) | ^^^^^^^^^^^^^^^^ move occurs because value has type `Option<Rc<RefCell<tree_node::TreeNode>>>`, which does not implement the `Copy` trait For more information about this error, try `rustc --explain E0507`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "226": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "101": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 33: Char 9: error: arguments to this function are incorrect (solution.rs) | 33 | is_symmetric_helper(root, root) | ^^^^^^^^^^^^^^^^^^^ | Line 33: Char 29: note: expected `Option<&TreeNode>`, found `Option<Rc<RefCell<TreeNode>>>` (solution.rs) | 33 | is_symmetric_helper(root, root) | ^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<Rc<RefCell<tree_node::TreeNode>>>` Line 33: Char 35: note: expected `Option<&TreeNode>`, found `Option<Rc<RefCell<TreeNode>>>` (solution.rs) | 33 | is_symmetric_helper(root, root) | ^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<Rc<RefCell<tree_node::TreeNode>>>` Line 23: Char 12: note: function defined here (solution.rs) | 23 | fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool { | ^^^^^^^^^^^^^^^^^^^ ----------------------- ------------------------ Line 27: Char 39: error: arguments to this function are incorrect (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^^ | Line 27: Char 59: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 27: Char 78: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 23: Char 12: note: function defined here (solution.rs) | 23 | fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool { | ^^^^^^^^^^^^^^^^^^^ ----------------------- ------------------------ Line 27: Char 101: error: arguments to this function are incorrect (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^^ | Line 27: Char 121: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 27: Char 141: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ...ht.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_deref()) | ^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 23: Char 12: note: function defined here (solution.rs) | 23 | fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool { | ^^^^^^^^^^^^^^^^^^^ ----------------------- ------------------------ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "105": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 36: Char 9: error: cannot assign to `root.left`, as `root` is not declared as mutable (solution.rs) | 36 | root.left = Self::build_tree(preorder[1..preorder_idx].to_vec(), inorder[0..inorder_idx].to_vec()); | ^^^^^^^^^ cannot assign | help: consider changing this to be mutable | 28 | let mut root = TreeNode::new(root_val); | +++ Line 37: Char 9: error: cannot assign to `root.right`, as `root` is not declared as mutable (solution.rs) | 37 | root.right = Self::build_tree(preorder[preorder_idx..].to_vec(), inorder[inorder_idx+1..].to_vec()); | ^^^^^^^^^^ cannot assign | help: consider changing this to be mutable | 28 | let mut root = TreeNode::new(root_val); | +++ For more information about this error, try `rustc --explain E0594`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "106": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 27: Char 24: error: cannot borrow `postorder` as mutable, as it is not declared as mutable (solution.rs) | 27 | let root_val = postorder.pop().unwrap(); | ^^^^^^^^^ cannot borrow as mutable | help: consider changing this to be mutable | 22 | pub fn build_tree(inorder: Vec<i32>, mut postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> { | +++ Line 38: Char 9: error: cannot assign to `root.left`, as `root` is not declared as mutable (solution.rs) | 38 | root.left = Self::build_tree(inorder[0..inorder_idx].to_vec(), postorder[0..inorder_idx].to_vec()); | ^^^^^^^^^ cannot assign | help: consider changing this to be mutable | 28 | let mut root = TreeNode::new(root_val); | +++ Line 39: Char 9: error: cannot assign to `root.right`, as `root` is not declared as mutable (solution.rs) | 39 | root.right = Self::build_tree(inorder[inorder_idx+1..].to_vec(), postorder[inorder_idx+1..].to_vec()); | ^^^^^^^^^^ cannot assign | help: consider changing this to be mutable | 28 | let mut root = TreeNode::new(root_val); | +++ Some errors have detailed explanations: E0594, E0596. For more information about an error, try `rustc --explain E0594`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "117": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "114": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 29: Char 27: error: mismatched types (solution.rs) | 24 | let mut current = node; | ---- expected due to this value ... 29 | current = next; | ^^^^ expected `&mut Rc<RefCell<TreeNode>>`, found `Rc<RefCell<TreeNode>>` | = note: expected mutable reference `&mut Rc<RefCell<tree_node::TreeNode>>` found struct `Rc<RefCell<tree_node::TreeNode>>` help: consider dereferencing here to assign to the mutably borrowed value | 29 | *current = next; | + Line 30: Char 24: error: mismatched types (solution.rs) | 26 | while let Some(mut next) = next { | -------- expected due to the type of this binding ... 30 | next = next_next; | ^^^^^^^^^ expected `Rc<RefCell<TreeNode>>`, found `Option<Rc<RefCell<TreeNode>>>` | = note: expected struct `Rc<_>` found enum `Option<Rc<_>>` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "112": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "129": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 32: Char 38: error: cannot move out of dereference of `Ref<'_, tree_node::TreeNode>` (solution.rs) | 32 | Self::sum_numbers_helper(node.left, sum); | ^^^^^^^^^ move occurs because value has type `Option<Rc<RefCell<tree_node::TreeNode>>>`, which does not implement the `Copy` trait Line 33: Char 38: error: cannot move out of dereference of `Ref<'_, tree_node::TreeNode>` (solution.rs) | 33 | Self::sum_numbers_helper(node.right, sum); | ^^^^^^^^^^ move occurs because value has type `Option<Rc<RefCell<tree_node::TreeNode>>>`, which does not implement the `Copy` trait For more information about this error, try `rustc --explain E0507`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "124": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 34: Char 24: error: cannot find function `max` in this scope (solution.rs) | 34 | *max_sum = max(*max_sum, sum); | ^^^ not found in this scope | help: consider importing one of these items | 20 + use core::cmp::max; | 20 + use std::cmp::max; | Line 33: Char 32: error: cannot add `()` to `i32` (solution.rs) | 33 | let sum = node.val + left_sum + right_sum; | ^ no implementation for `i32 + ()` | = help: the trait `Add<()>` is not implemented for `i32` = help: the following other types implement trait `Add<Rhs>`: <i32 as Add> <i32 as Add<&i32>> <&'a i32 as Add<i32>> <&i32 as Add<&i32>> Line 37: Char 13: error: mismatched types (solution.rs) | 28 | fn dfs(node: Option<Rc<RefCell<TreeNode>>>, max_sum: &mut i32) { | - expected `()` because of default return type ... 37 | 0 | ^ expected `()`, found integer Some errors have detailed explanations: E0277, E0308, E0425. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "173": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 33: Char 29: error: cannot move out of `self.current` as enum variant `Some` which is behind a mutable reference (solution.rs) | 33 | if let Some(node) = self.current { | ---- ^^^^^^^^^^^^ | | | data moved here | move occurs because `node` has type `Rc<RefCell<tree_node::TreeNode>>`, which does not implement the `Copy` trait | help: consider borrowing here | 33 | if let Some(node) = &self.current { | + For more information about this error, try `rustc --explain E0507`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "222": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 1: Char 6: error: expected one of `!` or `::`, found `typing` (solution.rs) | 1 | from typing import Optional | ^^^^^^ expected one of `!` or `::` error: could not compile `prog` (bin \"prog\") due to previous error"}, "236": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 1: Char 6: error: expected one of `!` or `::`, found `typing` (solution.rs) | 1 | from typing import Optional | ^^^^^^ expected one of `!` or `::` error: could not compile `prog` (bin \"prog\") due to previous error"}, "199": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "637": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 39: Char 21: error: cannot borrow `queue` as mutable more than once at a time (solution.rs) | 34 | for node in queue.drain(..) { | --------------- | | | first mutable borrow occurs here | first borrow later used here ... 39 | queue.push(left); | ^^^^^ second mutable borrow occurs here Line 43: Char 21: error: cannot borrow `queue` as mutable more than once at a time (solution.rs) | 34 | for node in queue.drain(..) { | --------------- | | | first mutable borrow occurs here | first borrow later used here ... 43 | queue.push(right); | ^^^^^ second mutable borrow occurs here For more information about this error, try `rustc --explain E0499`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "102": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 32: Char 36: error: mismatched types (solution.rs) | 25 | queue.push(root); | ----- ---- this argument has type `Option<Rc<RefCell<tree_node::TreeNode>>>`... | | | ... which causes `queue` to have type `Vec<Option<Rc<RefCell<tree_node::TreeNode>>>>` ... 32 | queue.push(left); | ---- ^^^^ expected `Option<Rc<RefCell<TreeNode>>>`, found `Rc<RefCell<TreeNode>>` | | | arguments to this method are incorrect | = note: expected enum `Option<Rc<_>>` found struct `Rc<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: try wrapping the expression in `Some` | 32 | queue.push(Some(left)); | +++++ + Line 35: Char 36: error: mismatched types (solution.rs) | 25 | queue.push(root); | ----- ---- this argument has type `Option<Rc<RefCell<tree_node::TreeNode>>>`... | | | ... which causes `queue` to have type `Vec<Option<Rc<RefCell<tree_node::TreeNode>>>>` ... 35 | queue.push(right); | ---- ^^^^^ expected `Option<Rc<RefCell<TreeNode>>>`, found `Rc<RefCell<TreeNode>>` | | | arguments to this method are incorrect | = note: expected enum `Option<Rc<_>>` found struct `Rc<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: try wrapping the expression in `Some` | 35 | queue.push(Some(right)); | +++++ + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "103": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 39: Char 38: error: `node` does not live long enough (solution.rs) | 34 | let node = queue.pop().unwrap(); | ---- binding `node` declared here ... 39 | if let Some(right) = node.borrow().right.clone() { | ^^^^--------- | | | borrowed value does not live long enough | a temporary with access to the borrow is created here ... ... 42 | } | - | | | `node` dropped here while still borrowed | ... and the borrow might be used here, when that temporary is dropped and runs the destructor for type `Ref<'_, tree_node::TreeNode>` | help: consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped | 41 | }; | + For more information about this error, try `rustc --explain E0597`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "530": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 36: Char 29: error: cannot find function `min` in this scope (solution.rs) | 36 | *min_diff = min(*min_diff, val - *prev_val); | ^^^ ... 64 | fn main() { | --------- similarly named function `main` defined here | help: a function with a similar name exists | 36 | *min_diff = main(*min_diff, val - *prev_val); | ~~~~ help: consider importing one of these items | 20 + use core::cmp::min; | 20 + use std::cmp::min; | Line 33: Char 42: error: no field `left` on type `Rc<RefCell<tree_node::TreeNode>>` (solution.rs) | 33 | Self::inorder_traversal(node.left, min_diff, prev_val); | ^^^^ unknown field Line 39: Char 42: error: no field `right` on type `Rc<RefCell<tree_node::TreeNode>>` (solution.rs) | 39 | Self::inorder_traversal(node.right, min_diff, prev_val); | ^^^^^ unknown field Some errors have detailed explanations: E0425, E0609. For more information about an error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "230": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 23: Char 25: error: failed to resolve: use of undeclared type `BinaryHeap` (solution.rs) | 23 | let mut queue = BinaryHeap::new(); | ^^^^^^^^^^ use of undeclared type `BinaryHeap` | help: consider importing this struct | 20 + use std::collections::BinaryHeap; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "98": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 23: Char 9: error: cannot find function `is_valid_bst_helper` in this scope (solution.rs) | 23 | is_valid_bst_helper(root, None, None) | ^^^^^^^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 23 | Self::is_valid_bst_helper(root, None, None) | ++++++ Line 42: Char 9: error: cannot find function `is_valid_bst_helper` in this scope (solution.rs) | 42 | is_valid_bst_helper(node.left, min, Some(node.val)) && is_valid_bst_helper(node.right, Some(node.val), max) | ^^^^^^^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 42 | Self::is_valid_bst_helper(node.left, min, Some(node.val)) && is_valid_bst_helper(node.right, Some(node.val), max) | ++++++ Line 42: Char 64: error: cannot find function `is_valid_bst_helper` in this scope (solution.rs) | 42 | is_valid_bst_helper(node.left, min, Some(node.val)) && is_valid_bst_helper(node.right, Some(node.val), max) | ^^^^^^^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 42 | is_valid_bst_helper(node.left, min, Some(node.val)) && Self::is_valid_bst_helper(node.right, Some(node.val), max) | ++++++ For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "200": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 31: error: mismatched types (solution.rs) | 8 | Self::dfs(grid, i, j); | --------- ^^^^ expected `&Vec<Vec<char>>`, found `Vec<Vec<char>>` | | | arguments to this function are incorrect | = note: expected reference `&Vec<Vec<char>>` found struct `Vec<Vec<char>>` Line 15: Char 8: note: associated function defined here (solution.rs) | 15 | fn dfs(grid: &Vec<Vec<char>>, i: usize, j: usize) { | ^^^ --------------------- help: consider borrowing here | 8 | Self::dfs(&grid, i, j); | + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "130": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "133": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "399": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 28: error: cannot find type `HashMap` in this scope (solution.rs) | 3 | let mut variables: HashMap<String, f64> = HashMap::new(); | ^^^^^^^ not found in this scope | help: consider importing this struct | 28+ use std::collections::HashMap; | Line 3: Char 51: error: failed to resolve: use of undeclared type `HashMap` (solution.rs) | 3 | let mut variables: HashMap<String, f64> = HashMap::new(); | ^^^^^^^ use of undeclared type `HashMap` | help: consider importing this struct | 28+ use std::collections::HashMap; | Some errors have detailed explanations: E0412, E0433. For more information about an error, try `rustc --explain E0412`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "207": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 25: error: the type `[bool]` cannot be indexed by `i32` (solution.rs) | 10 | if !visited[i] { | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[bool]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<bool>` to implement `std::ops::Index<i32>` Line 11: Char 25: error: mismatched types (solution.rs) | 11 | if !dfs(i, &mut graph, &mut visited, &mut stack) { | --- ^ expected `usize`, found `i32` | | | arguments to this function are incorrect | Line 20: Char 4: note: function defined here (solution.rs) | 20 | fn dfs(node: usize, graph: &mut Vec<Vec<usize>>, visited: &mut Vec<bool>, stack: &mut Vec<usize>) -> bool { | ^^^ ----------- help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit | 11 | if !dfs(i.try_into().unwrap(), &mut graph, &mut visited, &mut stack) { | ++++++++++++++++++++ Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "210": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 15: Char 26: error: the type `[{integer}]` cannot be indexed by `i32` (solution.rs) | 15 | if in_degree[i] == 0 { | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[{integer}]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<{integer}>` to implement `std::ops::Index<i32>` Line 23: Char 35: error: the type `[Vec<usize>]` cannot be indexed by `i32` (solution.rs) | 23 | for neighbor in graph[course].iter() { | ^^^^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<usize>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<usize>>` to implement `std::ops::Index<i32>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "909": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 15: Char 24: error: mismatched types (solution.rs) | 6 | let mut next = 1; | - expected due to this value ... 15 | next = board[current / n][current % n]; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "433": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 27: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut visited = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 37+ use std::collections::HashSet; | Line 4: Char 25: error: failed to resolve: use of undeclared type `VecDeque` (solution.rs) | 4 | let mut queue = VecDeque::new(); | ^^^^^^^^ use of undeclared type `VecDeque` | help: consider importing this struct | 37+ use std::collections::VecDeque; | Line 25: Char 39: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 25 | if i < mutation.len() && c != mutation[i] { | ^^^^^^^^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 26: Char 27: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 26 | new_gene.push(mutation[i]); | ^^^^^^^^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Some errors have detailed explanations: E0277, E0433. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "127": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 27: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut visited = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 24+ use std::collections::HashSet; | Line 4: Char 25: error: failed to resolve: use of undeclared type `VecDeque` (solution.rs) | 4 | let mut queue = VecDeque::new(); | ^^^^^^^^ use of undeclared type `VecDeque` | help: consider importing this struct | 24+ use std::collections::VecDeque; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "208": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 46: Char 15: error: cannot find type `HashMap` in this scope (solution.rs) | 46 | children: HashMap<char, Box<TrieNode>>, | ^^^^^^^ not found in this scope | help: consider importing this struct | 62 + use std::collections::HashMap; | Line 53: Char 23: error: failed to resolve: use of undeclared type `HashMap` (solution.rs) | 53 | children: HashMap::new(), | ^^^^^^^ use of undeclared type `HashMap` | help: consider importing this struct | 62 + use std::collections::HashMap; | Some errors have detailed explanations: E0412, E0433. For more information about an error, try `rustc --explain E0412`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "211": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 9: error: cannot borrow `self.words` as mutable, as it is behind a `&` reference (solution.rs) | 13 | self.words.push(word); | ^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable | help: consider changing this to be a mutable reference | 12 | fn add_word(&mut self, word: String) { | ~~~~~~~~~ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "212": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "17": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "77": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 7: Char 33: error: mismatched types (solution.rs) | 7 | if current.len() == k { | ^ expected `usize`, found `i32` Line 7: Char 30: error: can't compare `usize` with `i32` (solution.rs) | 7 | if current.len() == k { | ^^ no implementation for `usize == i32` | = help: the trait `PartialEq<i32>` is not implemented for `usize` = help: the following other types implement trait `PartialEq<Rhs>`: <usize as PartialEq> <usize as PartialEq<Value>> Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "46": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 15: Char 13: error: cannot borrow `*nums` as mutable, as it is behind a `&` reference (solution.rs) | 15 | nums.swap(start, i); | ^^^^ `nums` is a `&` reference, so the data it refers to cannot be borrowed as mutable | help: consider changing this to be a mutable reference | 8 | fn permute_helper(nums: &mut [i32], result: &mut Vec<Vec<i32>>, start: usize) { | +++ Line 17: Char 13: error: cannot borrow `*nums` as mutable, as it is behind a `&` reference (solution.rs) | 17 | nums.swap(start, i); | ^^^^ `nums` is a `&` reference, so the data it refers to cannot be borrowed as mutable | help: consider changing this to be a mutable reference | 8 | fn permute_helper(nums: &mut [i32], result: &mut Vec<Vec<i32>>, start: usize) { | +++ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "39": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "52": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 27: error: the type `[Vec<bool>]` cannot be indexed by `i32` (solution.rs) | 8 | if !board[row][col] { | ^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<bool>>` to implement `std::ops::Index<i32>` Line 9: Char 27: error: the type `[Vec<bool>]` cannot be indexed by `i32` (solution.rs) | 9 | board[row][col] = true; | ^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<bool>>` to implement `std::ops::Index<i32>` Line 12: Char 46: error: the type `[Vec<bool>]` cannot be indexed by `i32` (solution.rs) | 12 | if i != row && board[i][col] { | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<bool>>` to implement `std::ops::Index<i32>` Line 14: Char 35: error: the type `[Vec<bool>]` cannot be indexed by `i32` (solution.rs) | 14 | ... board[i][col] = false; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<bool>>` to implement `std::ops::Index<i32>` Line 18: Char 46: error: the type `[Vec<bool>]` cannot be indexed by `i32` (solution.rs) | 18 | if j != col && board[row][j] { | ^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<bool>>` to implement `std::ops::Index<i32>` Line 20: Char 35: error: the type `[Vec<bool>]` cannot be indexed by `i32` (solution.rs) | 20 | ... board[row][j] = false; | ^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<Vec<bool>>` to implement `std::ops::Index<i32>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 6 previous errors"}, "22": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "79": {"compiled": "false", "verdict": "Context-Length Exceeded", "stderr": "Context-Length Exceeded"}, "108": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 1: Char 7: error: expected one of `!` or `::`, found `Solution` (solution.rs) | 1 | class Solution: | ^^^^^^^^ expected one of `!` or `::` error: could not compile `prog` (bin \"prog\") due to previous error"}, "148": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 25: Char 32: error: use of partially moved value: `node` (solution.rs) | 24 | head = node.next; | --------- value partially moved here 25 | sorted_head = Some(node); | ^^^^ value used here after partial move | = note: partial move occurs because `node.next` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "427": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "23": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 1: Char 5: error: expected one of `!` or `::`, found `merge_k_lists` (solution.rs) | 1 | def merge_k_lists(lists): | --- ^^^^^^^^^^^^^ expected one of `!` or `::` | | | help: write `fn` instead of `def` to declare a function error: could not compile `prog` (bin \"prog\") due to previous error"}, "53": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "918": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 12: Char 35: error: mismatched types (solution.rs) | 12 | start_index = i - (current_sum - max_sum); | ^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32` Line 12: Char 33: error: cannot subtract `i32` from `usize` (solution.rs) | 12 | start_index = i - (current_sum - max_sum); | ^ no implementation for `usize - i32` | = help: the trait `Sub<i32>` is not implemented for `usize` = help: the following other types implement trait `Sub<Rhs>`: <usize as Sub> <usize as Sub<&usize>> <&'a usize as Sub<usize>> <&usize as Sub<&usize>> Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "35": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 8: Char 20: index out of bounds: the len is 4 but the index is 9223372036854775807 (solution.rs)"}, "74": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 14: Char 22: index out of bounds: the len is 1 but the index is 9223372036854775807 (solution.rs)"}, "162": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 16: Char 13: error: mismatched types (solution.rs) | 2 | pub fn find_peak_element(nums: Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 16 | left | ^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 16 | left.try_into().unwrap() | ++++++++++++++++++++ Line 18: Char 13: error: mismatched types (solution.rs) | 2 | pub fn find_peak_element(nums: Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 18 | right | ^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 18 | right.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "33": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 8: Char 20: index out of bounds: the len is 7 but the index is 9223372036854775807 (solution.rs)"}, "34": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 8: Char 20: index out of bounds: the len is 0 but the index is 9223372036854775807 (solution.rs)"}, "153": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "4": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 23: Char 45: error: mismatched closing delimiter: `)` (solution.rs) | 23 | let (median, _) = if m + n % 2 == 0 { | ^ unclosed delimiter 24 | (max_left + min_right) / 2.0, true) | ^ mismatched closing delimiter Line 31: Char 1: error: unexpected closing delimiter: `}` (solution.rs) | 24 | (max_left + min_right) / 2.0, true) | - missing open `(` for this delimiter ... 31 | } | ^ unexpected closing delimiter error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "215": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "502": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 17: Char 20: error: mismatched types (solution.rs) | 17 | if i < projects.len() { | - ^^^^^^^^^^^^^^ expected `i32`, found `usize` | | | expected because this is `i32` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 17 | if i < projects.len().try_into().unwrap() { | ++++++++++++++++++++ Line 18: Char 41: error: the type `[(i32, i32)]` cannot be indexed by `i32` (solution.rs) | 18 | max_capital += projects[i].0; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[(i32, i32)]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<(i32, i32)>` to implement `std::ops::Index<i32>` Line 19: Char 45: error: the type `[(i32, i32)]` cannot be indexed by `i32` (solution.rs) | 19 | current_capital += projects[i].1; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[(i32, i32)]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<(i32, i32)>` to implement `std::ops::Index<i32>` Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "373": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 13: error: cannot assign to immutable argument `k` (solution.rs) | 2 | pub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> { | - help: consider making this binding mutable: `mut k` ... 13 | k -= 1; | ^^^^^^ cannot assign to immutable argument For more information about this error, try `rustc --explain E0384`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "295": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 9: error: cannot borrow `self.nums` as mutable, as it is behind a `&` reference (solution.rs) | 13 | self.nums.push(num); | ^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable | help: consider changing this to be a mutable reference | 12 | fn add_num(&mut self, num: i32) { | ~~~~~~~~~ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "67": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 11: Char 25: error: mismatched types (solution.rs) | 11 | result.push(sum.to_string()); | ---- ^^^^^^^^^^^^^^^ expected `char`, found `String` | | | arguments to this method are incorrect | Line 1193: Char 12: note: method defined here (solution.rs) Line 17: Char 25: error: mismatched types (solution.rs) | 17 | result.push(carry.to_string()); | ---- ^^^^^^^^^^^^^^^^^ expected `char`, found `String` | | | arguments to this method are incorrect | Line 1193: Char 12: note: method defined here (solution.rs) For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "190": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "191": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "136": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 24: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 18+ use std::collections::HashSet; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "137": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 24: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 3 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 18+ use std::collections::HashSet; | For more information about this error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "201": {"compiled": "true", "verdict": "Time Limit Exceeded", "stderr": "Time Limit Exceeded"}, "9": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "66": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "172": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "69": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "50": {"compiled": "true", "verdict": "Runtime Error", "stderr": "thread 'main' has overflowed its stack (solution.rs)"}, "149": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 4: Char 24: error: failed to resolve: use of undeclared type `HashSet` (solution.rs) | 4 | let mut seen = HashSet::new(); | ^^^^^^^ use of undeclared type `HashSet` | help: consider importing this struct | 38+ use std::collections::HashSet; | Line 28: Char 26: error: cannot find function `max` in this scope (solution.rs) | 28 | max_points = max(max_points, count); | ^^^ not found in this scope | help: consider importing one of these items | 38 + use core::cmp::max; | 38 + use std::cmp::max; | Some errors have detailed explanations: E0425, E0433. For more information about an error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "70": {"compiled": "true", "verdict": "Time Limit Exceeded", "stderr": "Time Limit Exceeded"}, "198": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 6: Char 21: error: cannot find function `max` in this scope (solution.rs) | 6 | dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); | ^^^ not found in this scope | help: consider importing one of these items | 15+ use core::cmp::max; | 15+ use std::cmp::max; | For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "139": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 52: error: mismatched types (solution.rs) | 8 | if dp[j - 1] && word_dict.contains(&s[j - 1..i]) { | -------- ^^^^^^^^^^^^ expected `&String`, found `&str` | | | arguments to this method are incorrect | = note: expected reference `&std::string::String` found reference `&str` Line 2512: Char 12: note: method defined here (solution.rs) For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "322": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 44: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 10 | if i - coins[j] >= 0 && dp[i - coins[j]] + 1 < dp[i] { | ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 10: Char 67: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 10 | if i - coins[j] >= 0 && dp[i - coins[j]] + 1 < dp[i] { | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 11: Char 24: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 11 | dp[i] = dp[i - coins[j]] + 1; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 11: Char 32: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 11 | dp[i] = dp[i - coins[j]] + 1; | ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 17: Char 15: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 17 | if dp[amount] == amount { | ^^^^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 20: Char 16: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 20 | dp[amount] | ^^^^^^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 6 previous errors"}, "300": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 31: error: cannot find function `max` in this scope (solution.rs) | 10 | max_len = max(max_len, dp[i]); | ^^^ not found in this scope | help: consider importing one of these items | 22 + use core::cmp::max; | 22 + use std::cmp::max; | For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "120": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "64": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 17: Char 32: error: cannot find function `min` in this scope (solution.rs) | 17 | dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; | ^^^ ... 46 | fn main() { | --------- similarly named function `main` defined here | help: a function with a similar name exists | 17 | dp[i][j] = main(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; | ~~~~ help: consider importing one of these items | 29 + use core::cmp::min; | 29 + use std::cmp::min; | For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "63": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 13: Char 34: index out of bounds: the len is 3 but the index is 18446744073709551615 (solution.rs)"}, "5": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 37: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 8 | current_palindrome.push(s[i]); | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 11: Char 20: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 11 | if s[i] == s[j] && current_palindrome.len() < 2 { | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 11: Char 28: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 11 | if s[i] == s[j] && current_palindrome.len() < 2 { | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 12: Char 45: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 12 | current_palindrome.push(s[j]); | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 13: Char 27: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 13 | } else if s[i] == s[j] && current_palindrome.len() == 2 { | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 13: Char 35: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 13 | } else if s[i] == s[j] && current_palindrome.len() == 2 { | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> Line 18: Char 45: error: the type `std::string::String` cannot be indexed by `usize` (solution.rs) | 18 | current_palindrome.push(s[i]); | ^^^^ `std::string::String` cannot be indexed by `usize` | = help: the trait `std::ops::Index<usize>` is not implemented for `std::string::String` = help: the following other types implement trait `std::ops::Index<Idx>`: <std::string::String as std::ops::Index<RangeFull>> <std::string::String as std::ops::Index<std::ops::Range<usize>>> <std::string::String as std::ops::Index<RangeFrom<usize>>> <std::string::String as std::ops::Index<RangeTo<usize>>> <std::string::String as std::ops::Index<RangeInclusive<usize>>> <std::string::String as std::ops::Index<RangeToInclusive<usize>>> For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 7 previous errors"}, "97": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 12: Char 19: error: the type `str` cannot be indexed by `usize` (solution.rs) | 12 | if s1[s1_idx] == s3[s3_idx] { | ^^^^^^ string indices are ranges of `usize` | = help: the trait `SliceIndex<str>` is not implemented for `usize` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `str` to implement `std::ops::Index<usize>` Line 12: Char 33: error: the type `str` cannot be indexed by `usize` (solution.rs) | 12 | if s1[s1_idx] == s3[s3_idx] { | ^^^^^^ string indices are ranges of `usize` | = help: the trait `SliceIndex<str>` is not implemented for `usize` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `str` to implement `std::ops::Index<usize>` Line 15: Char 19: error: the type `str` cannot be indexed by `usize` (solution.rs) | 15 | if s2[s2_idx] == s3[s3_idx] { | ^^^^^^ string indices are ranges of `usize` | = help: the trait `SliceIndex<str>` is not implemented for `usize` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `str` to implement `std::ops::Index<usize>` Line 15: Char 33: error: the type `str` cannot be indexed by `usize` (solution.rs) | 15 | if s2[s2_idx] == s3[s3_idx] { | ^^^^^^ string indices are ranges of `usize` | = help: the trait `SliceIndex<str>` is not implemented for `usize` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `str` to implement `std::ops::Index<usize>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "72": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "123": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 15: Char 30: error: cannot find function `max` in this scope (solution.rs) | 15 | max_profit = max(max_profit, sell_price.unwrap() - buy_price.unwrap()); | ^^^ not found in this scope | help: consider importing one of these items | 28 + use core::cmp::max; | 28 + use std::cmp::max; | Line 8: Char 47: error: mismatched types (solution.rs) | 8 | if buy_price.is_none() && price < sell_price { | ----- ^^^^^^^^^^ expected `i32`, found `Option<_>` | | | expected because this is `i32` | = note: expected type `i32` found enum `Option<_>` Line 10: Char 55: error: mismatched types (solution.rs) | 10 | } else if sell_price.is_none() && price > buy_price { | ----- ^^^^^^^^^ expected `i32`, found `Option<i32>` | | | expected because this is `i32` | = note: expected type `i32` found enum `Option<i32>` Some errors have detailed explanations: E0308, E0425. For more information about an error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "188": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 20: error: mismatched types (solution.rs) | 8 | if i < k { | - ^ expected `usize`, found `i32` | | | expected because this is `usize` | help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit | 8 | if i < k.try_into().unwrap() { | ++++++++++++++++++++ Line 16: Char 39: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 16 | max_profit += sell_prices[i] - buy_prices[i]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 16: Char 55: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 16 | max_profit += sell_prices[i] - buy_prices[i]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "221": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 15: Char 32: error: cannot find function `max` in this scope (solution.rs) | 15 | max_area = max(max_area, area); | ^^^ not found in this scope | help: consider importing one of these items | 26 + use core::cmp::max; | 26 + use std::cmp::max; | For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to previous error"}}