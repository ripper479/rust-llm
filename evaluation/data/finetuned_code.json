{"88": "rust\npub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n    let mut i = m as usize - 1;\n    let mut j = n as usize - 1;\n    let mut k = m + n as usize - 1;\n\n    while i >= 0 && j >= 0 {\n        if nums1[i] > nums2[j] {\n            nums1[k] = nums1[i];\n            i -= 1;\n        } else {\n            nums1[k] = nums2[j];\n            j -= 1;\n        }\n        k -= 1;\n    }\n\n    while j >= 0 {\n        nums1[k] = nums2[j];\n        j -= 1;\n        k -= 1;\n    }\n}\n", "27": "rust\npub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n    let mut k = 0;\n    for i in 0..nums.len() {\n        if nums[i] != val {\n            nums.swap(k, i);\n            k += 1;\n        }\n    }\n    k\n}\n", "26": "rust\npub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n    let mut unique_count = 1;\n    for i in 1..nums.len() {\n        if nums[i] != nums[i - 1] {\n            nums[unique_count] = nums[i];\n            unique_count += 1;\n        }\n    }\n    unique_count as i32\n}\n", "80": "rust\npub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n    let mut i = 0;\n    let mut j = 1;\n    let mut count = 1;\n\n    while j < nums.len() {\n        if nums[i] != nums[j] {\n            i += 1;\n            nums[i] = nums[j];\n            count += 1;\n        }\n        j += 1;\n    }\n\n    count\n}\n", "169": "rust\npub fn majority_element(nums: Vec<i32>) -> i32 {\n    let mut count = 0;\n    let mut candidate = nums[0];\n\n    for &num in nums.iter() {\n        if count == 0 {\n            candidate = num;\n        }\n        count += if num == candidate { 1 } else { -1 };\n    }\n\n    candidate\n}\n", "189": "rust\npub fn rotate(nums: &mut Vec<i32>, k: i32) {\n    let len = nums.len();\n    let k = k as usize % len;\n    nums.rotate_right(k);\n}\n", "121": "rust\npub fn max_profit(prices: Vec<i32>) -> i32 {\n    let mut min_price = i32::MAX;\n    let mut max_profit = 0;\n\n    for &price in prices.iter() {\n        if price < min_price {\n            min_price = price;\n        } else if price - min_price > max_profit {\n            max_profit = price - min_price;\n        }\n    }\n\n    max_profit\n}\n", "122": "rust\npub fn max_profit(prices: Vec<i32>) -> i32 {\n    let mut min_price = i32::MAX;\n    let mut max_profit = 0;\n\n    for &price in prices.iter() {\n        if price < min_price {\n            min_price = price;\n        } else if price - min_price > max_profit {\n            max_profit = price - min_price;\n        }\n    }\n\n    max_profit\n}\n", "55": "rust\npub fn can_jump(nums: Vec<i32>) -> bool {\n    let mut max_reach = 0;\n    for i in 0..nums.len() {\n        if i > max_reach {\n            return false;\n        }\n        max_reach = std::cmp::max(max_reach, i + nums[i] as usize);\n    }\n    true\n}\n", "45": "rust\npub fn jump(nums: Vec<i32>) -> i32 {\n    let n = nums.len();\n    let mut dp = vec![n as i32; n];\n    dp[0] = 0;\n\n    for i in 1..n {\n        for j in 1..=nums[i as usize] as usize {\n            let next = i + j;\n            if next < n {\n                dp[next] = dp[i] + 1;\n            }\n        }\n    }\n\n    dp[n - 1]\n}\n", "274": "rust\npub fn h_index(citations: Vec<i32>) -> i32 {\n    let mut citations = citations;\n    citations.sort_unstable_by(|a, b| b.cmp(a));\n    let mut count = 0;\n    for (i, &citation) in citations.iter().enumerate() {\n        if citation >= i as i32 + 1 {\n            count = i as i32 + 1;\n            break;\n        }\n    }\n    count\n}\n", "380": "rust\nuse rand::{thread_rng, Rng};\nuse std::collections::HashSet;\n\nstruct RandomizedSet {\n    set: HashSet<i32>,\n}\n\nimpl RandomizedSet {\n    fn new() -> Self {\n        RandomizedSet {\n            set: HashSet::new(),\n        }\n    }\n\n    fn insert(&mut self, val: i32) -> bool {\n        self.set.insert(val)\n    }\n\n    fn remove(&mut self, val: i32) -> bool {\n        self.set.remove(&val)\n    }\n\n    fn get_random(&self) -> i32 {\n        let mut rng = thread_rng();\n        let mut iter = self.set.iter();\n        let random_index = rng.gen_range(0..self.set.len());\n        iter.nth(random_index).cloned().unwrap()\n    }\n}\n", "238": "rust\npub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n    let n = nums.len();\n    let mut left_product = 1;\n    let mut right_product = 1;\n    let mut result = vec![1; n];\n\n    for i in 0..n {\n        result[i] = left_product * right_product;\n        left_product *= nums[i];\n    }\n\n    for i in (0..n).rev() {\n        result[i] *= right_product;\n        right_product *= nums[i];\n    }\n\n    result\n}\n", "134": "rust\npub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\n    let n = gas.len();\n    let mut start = 0;\n    let mut end = 0;\n    let mut total_gas = 0;\n    let mut total_cost = 0;\n\n    for i in 0..n {\n        total_gas += gas[i as usize];\n        total_cost += cost[i as usize];\n\n        if total_gas < total_cost {\n            start = i + 1;\n            total_gas = 0;\n        }\n\n        if total_gas >= total_cost {\n            end = i;\n        }\n    }\n\n    if total_gas >= total_cost {\n        return start;\n    } else {\n        return -1;\n    }\n}\n", "135": "rust\npub fn candy(ratings: Vec<i32>) -> i32 {\n    let n = ratings.len();\n    let mut candies = vec![1; n];\n    let mut inc = 1;\n\n    for i in 1..n {\n        if ratings[i] > ratings[i - 1] {\n            candies[i] = candies[i - 1] + 1;\n            inc = candies[i];\n        } else {\n            inc = 1;\n        }\n    }\n\n    for i in (0..n).rev() {\n        if ratings[i] > ratings[i + 1] {\n            candies[i] = std::cmp::max(candies[i], inc);\n            inc = candies[i];\n        }\n    }\n\n    candies.into_iter().sum()\n}\n", "42": "rust\npub fn trap(height: Vec<i32>) -> i32 {\n    let mut left = 0;\n    let mut right = height.len() - 1;\n    let mut left_max = height[left];\n    let mut right_max = height[right];\n    let mut water = 0;\n\n    while left < right {\n        if left_max < right_max {\n            if height[left] < left_max {\n                water += left_max - height[left];\n            } else {\n                left_max = height[left];\n            }\n            left += 1;\n        } else {\n            if height[right] < right_max {\n                water += right_max - height[right];\n            } else {\n                right_max = height[right];\n            }\n            right -= 1;\n        }\n    }\n\n    water\n}\n", "13": "rust\npub fn roman_to_int(s: String) -> i32 {\n    let mut result = 0;\n    let mut prev = 0;\n    let mut next = 0;\n\n    for c in s.chars() {\n        match c {\n            'I' => {\n                result += 1;\n                prev = 1;\n            }\n            'V' => {\n                result += 5;\n                prev = 5;\n            }\n            'X' => {\n                result += 10;\n                prev = 10;\n            }\n            'L' => {\n                result += 50;\n                prev = 50;\n            }\n            'C' => {\n                result += 100;\n                prev = 100;\n            }\n            'D' => {\n                result += 500;\n                prev = 500;\n            }\n            'M' => {\n                result += 1000;\n                prev = 1000;\n            }\n            _ => panic!(\"Invalid character in roman numeral\"),\n        }\n\n        if prev > next {\n            result -= prev;\n        }\n    }\n\n    result\n}\n", "12": "rust\npub fn int_to_roman(num: i32) -> String {\n    let mut result = String::new();\n    let mut num = num;\n\n    let mut roman_numerals = [\n        (\"M\", 1000),\n        (\"CM\", 900),\n        (\"D\", 500),\n        (\"CD\", 400),\n        (\"C\", 100),\n        (\"XC\", 90),\n        (\"L\", 50),\n        (\"XL\", 40),\n        (\"X\", 10),\n        (\"IX\", 9),\n        (\"V\", 5),\n        (\"IV\", 4),\n        (\"I\", 1),\n    ];\n\n    while num > 0 {\n        for (roman_numeral, value) in &roman_numerals {\n            while num >= value {\n                result.push_str(roman_numeral);\n                num -= value;\n            }\n        }\n    }\n\n    result\n}\n", "58": "rust\npub fn length_of_last_word(s: String) -> i32 {\n    let words: Vec<&str> = s.split_whitespace().collect();\n    words.last().map_or(0, |word| word.len() as i32)\n}\n", "14": "rust\npub fn longest_common_prefix(strs: Vec<String>) -> String {\n    let mut prefix = String::new();\n    let mut min_len = std::usize::MAX;\n\n    for s in &strs {\n        min_len = min_len.min(s.len());\n    }\n\n    for i in 0..min_len {\n        let c = strs[0].chars().nth(i).unwrap();\n        for s in &strs {\n            if s.chars().nth(i) != Some(c) {\n                return prefix;\n            }\n        }\n        prefix.push(c);\n    }\n\n    prefix\n}\n", "151": "rust\npub fn reverse_words(s: &mut String) {\n    let mut words = s.split_whitespace();\n    let mut reversed_words = words.rev();\n    let mut reversed_string = String::new();\n\n    for word in reversed_words {\n        reversed_string.push_str(word);\n        reversed_string.push(' ');\n    }\n\n    reversed_string.pop(); // Remove the last space\n    *s = reversed_string;\n}\n", "6": "rust\npub fn convert(s: String, num_rows: i32) -> String {\n    let s = s.chars().collect::<Vec<char>>();\n    let len = s.len();\n    let mut result = String::new();\n\n    if num_rows == 1 {\n        return s.into_iter().collect::<String>();\n    }\n\n    let mut row_size = (len as f64 / (num_rows as f64 - 1.0)).ceil() as usize;\n    let mut row_size_down = (len as f64 / (num_rows as f64 - 1.0)).floor() as usize;\n\n    let mut row_index = 0;\n    let mut row_index_down = num_rows - 2;\n\n    for i in 0..len {\n        result.push(s[i]);\n\n        if row_index < num_rows - 1 {\n            row_index += 1;\n        } else {\n            row_index = 0;\n        }\n\n        if row_index_down > 0 {\n            row_index_down -= 1;\n        } else {\n            row_index_down = num_rows - 2;\n        }\n    }\n\n    result\n}\n", "28": "rust\npub fn str_str(haystack: String, needle: String) -> i32 {\n    haystack.find(&needle).map_or(-1, |i| i as i32)\n}\n", "68": "rust\npub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut current_line = String::new();\n    let mut current_length = 0;\n\n    for word in words {\n        let word_length = word.len() as i32;\n        if current_length + word_length > max_width {\n            result.push(current_line);\n            current_line = word.clone();\n            current_length = word_length;\n        } else {\n            if !current_line.is_empty() {\n                current_line.push(' ');\n            }\n            current_line.push_str(&word);\n            current_length += word_length;\n        }\n    }\n\n    result.push(current_line);\n\n    result\n}\n", "125": "rust\npub fn is_palindrome(s: String) -> bool {\n    let s = s.chars().filter(|c| c.is_alphanumeric()).collect::<String>();\n    s == s.chars().rev().collect::<String>()\n}\n", "392": "rust\npub fn is_subsequence(s: String, t: String) -> bool {\n    let s = s.chars().collect::<Vec<char>>();\n    let t = t.chars().collect::<Vec<char>>();\n    let mut i = 0;\n    for c in t {\n        if i < s.len() && s[i] == c {\n            i += 1;\n        }\n    }\n    i == s.len()\n}\n", "167": "rust\npub fn two_sum(numbers: &[i32], target: i32) -> Option<[i32; 2]> {\n    let (mut left, mut right) = (0, numbers.len() - 1);\n    while left < right {\n        let sum = numbers[left] + numbers[right];\n        match sum.cmp(&target) {\n            std::cmp::Ordering::Less => left += 1,\n            std::cmp::Ordering::Greater => right -= 1,\n            std::cmp::Ordering::Equal => return Some([left + 1, right + 1]),\n        }\n    }\n    None\n}\n", "11": "rust\npub fn max_area(height: Vec<i32>) -> i32 {\n    let mut max_area = 0;\n    let mut left = 0;\n    let mut right = height.len() - 1;\n\n    while left < right {\n        let area = (right - left) as i32 * height[left].min(height[right]);\n        max_area = max_area.max(area);\n\n        if height[left] < height[right] {\n            left += 1;\n        } else {\n            right -= 1;\n        }\n    }\n\n    max_area\n}\n", "15": "rust\npub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {\n    let mut result = Vec::new();\n    let mut nums = nums;\n    nums.sort();\n    for i in 0..nums.len() {\n        if i > 0 && nums[i] == nums[i - 1] {\n            continue;\n        }\n        let target = -nums[i];\n        let mut left = i + 1;\n        let mut right = nums.len() - 1;\n        while left < right {\n            let sum = nums[left] + nums[right];\n            if sum == target {\n                result.push(vec![nums[i], nums[left], nums[right]]);\n                left += 1;\n                right -= 1;\n                while left < right && nums[left] == nums[left - 1] {\n                    left += 1;\n                }\n                while left < right && nums[right] == nums[right + 1] {\n                    right -= 1;\n                }\n            } else if sum < target {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n    result\n}\n", "209": "rust\npub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {\n    let mut sum = 0;\n    let mut min_len = i32::MAX;\n    let mut start = 0;\n    let mut end = 0;\n\n    while end < nums.len() {\n        sum += nums[end];\n        while sum >= target {\n            min_len = min_len.min(end - start + 1);\n            sum -= nums[start];\n            start += 1;\n        }\n        end += 1;\n    }\n\n    if min_len == i32::MAX {\n        0\n    } else {\n        min_len\n    }\n}\n", "3": "rust\npub fn length_of_longest_substring(s: String) -> i32 {\n    let mut start = 0;\n    let mut max_len = 0;\n    let mut char_map = std::collections::HashMap::new();\n\n    for (i, c) in s.chars().enumerate() {\n        if let Some(prev_i) = char_map.insert(c, i) {\n            start = std::cmp::max(start, prev_i + 1);\n        }\n        max_len = std::cmp::max(max_len, i - start + 1);\n    }\n\n    max_len as i32\n}\n", "30": "rust\npub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n    let s = s.as_bytes();\n    let words: Vec<Vec<u8>> = words.into_iter().map(|word| word.as_bytes().to_vec()).collect();\n    let word_len = words[0].len();\n    let word_count = words.len();\n    let mut result = Vec::new();\n\n    for i in 0..s.len() - word_len * word_count + 1 {\n        let mut j = 0;\n        while j < word_count && s[i + j * word_len..i + (j + 1) * word_len] == words[j] {\n            j += 1;\n        }\n        if j == word_count {\n            result.push(i as i32);\n        }\n    }\n\n    result\n}\n", "76": "rust\npub fn min_window(s: String, t: String) -> String {\n    let s = s.chars().collect::<Vec<char>>();\n    let t = t.chars().collect::<Vec<char>>();\n    let mut t_count = [0; 128];\n    let mut s_count = [0; 128];\n    let mut min_window_start = 0;\n    let mut min_window_end = 0;\n    let mut min_window_size = s.len();\n\n    for c in t {\n        t_count[c as usize] += 1;\n    }\n\n    for (i, c) in s.iter().enumerate() {\n        s_count[*c as usize] += 1;\n        if s_count[*c as usize] <= t_count[*c as usize] {\n            min_window_size = i + 1;\n        }\n    }\n\n    for (i, c) in s.iter().enumerate() {\n        if s_count[*c as usize] == t_count[*c as usize] {\n            min_window_start = i;\n            break;\n        }\n    }\n\n    for (i, c) in s.iter().enumerate().rev() {\n        if s_count[*c as usize] == t_count[*c as usize] {\n            min_window_end = i;\n            break;\n        }\n    }\n\n    if min_window_size == s.len() {\n        return \"\".to_string();\n    }\n\n    s[min_window_start..=min_window_end].iter().collect()\n}\n", "36": "rust\npub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n    let mut rows = [0; 9];\n    let mut cols = [0; 9];\n    let mut boxes = [[0; 9]; 9];\n\n    for i in 0..9 {\n        for j in 0..9 {\n            let c = board[i][j];\n            if c != '.' {\n                let index = c.to_digit(10).unwrap() as usize - 1;\n                rows[i] |= 1 << index;\n                cols[j] |= 1 << index;\n                boxes[i / 3][j / 3] |= 1 << index;\n            }\n        }\n    }\n\n    for row in rows.iter() {\n        if row.count_ones() != 9 {\n            return false;\n        }\n    }\n\n    for col in cols.iter() {\n        if col.count_ones() != 9 {\n            return false;\n        }\n    }\n\n    for box in boxes.iter() {\n        if box.count_ones() != 9 {\n            return false;\n        }\n    }\n\n    true\n}\n", "54": "rust\npub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n    let m = matrix.len();\n    let n = matrix[0].len();\n    let mut result = Vec::new();\n    let mut top = 0;\n    let mut bottom = m - 1;\n    let mut left = 0;\n    let mut right = n - 1;\n\n    while top <= bottom && left <= right {\n        for i in left..=right {\n            result.push(matrix[top][i]);\n        }\n        top += 1;\n\n        for i in top..=bottom {\n            result.push(matrix[i][right]);\n        }\n        right -= 1;\n\n        if top <= bottom {\n            for i in (left..=right).rev() {\n                result.push(matrix[bottom][i]);\n            }\n            bottom -= 1;\n        }\n\n        if left <= right {\n            for i in (top..=bottom).rev() {\n                result.push(matrix[i][left]);\n            }\n            left += 1;\n        }\n    }\n\n    result\n}\n", "48": "rust\npub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n    let n = matrix.len();\n    for layer in 0..n / 2 {\n        for i in layer..n - layer - 1 {\n            let temp = matrix[layer][i];\n            matrix[layer][i] = matrix[n - i - 1][layer];\n            matrix[n - i - 1][layer] = matrix[n - layer - 1][n - i - 1];\n            matrix[n - layer - 1][n - i - 1] = matrix[i][n - layer - 1];\n            matrix[i][n - layer - 1] = temp;\n        }\n    }\n}\n", "73": "rust\npub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n    let m = matrix.len();\n    let n = matrix[0].len();\n    let mut row_zeroes = vec![false; m];\n    let mut col_zeroes = vec![false; n];\n\n    for i in 0..m {\n        for j in 0..n {\n            if matrix[i][j] == 0 {\n                row_zeroes[i] = true;\n                col_zeroes[j] = true;\n            }\n        }\n    }\n\n    for i in 0..m {\n        if row_zeroes[i] {\n            matrix[i].iter_mut().for_each(|x| *x = 0);\n        }\n    }\n\n    for j in 0..n {\n        if col_zeroes[j] {\n            for i in 0..m {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n}\n", "289": "rust\npub fn game_of_life(board: &mut Vec<Vec<i32>>) {\n    let m = board.len();\n    let n = board[0].len();\n\n    for i in 0..m {\n        for j in 0..n {\n            let neighbors = count_neighbors(board, i, j);\n            let current_state = board[i][j];\n\n            if current_state == 1 {\n                if neighbors < 2 {\n                    board[i][j] = 0;\n                } else if neighbors == 2 || neighbors == 3 {\n                    board[i][j] = 1;\n                } else if neighbors > 3 {\n                    board[i][j] = 0;\n                }\n            } else {\n                if neighbors == 3 {\n                    board[i][j] = 1;\n                }\n            }\n        }\n    }\n}\n\nfn count_neighbors(board: &Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\n    let m = board.len();\n    let n = board[0].len();\n\n    let mut count = 0;\n\n    for di in -1..=1 {\n        for dj in -1..=1 {\n            let ni = (i as i32 + di) as usize;\n            let nj = (j as i32 + dj) as usize;\n\n            if ni >= m || nj >= n || ni < 0 || nj < 0 {\n                continue;\n            }\n\n            count += board[ni][nj];\n        }\n    }\n\n    count\n}\n", "383": "rust\npub fn can_construct(ransom_note: String, magazine: String) -> bool {\n    let mut magazine_count = [0; 26];\n    for c in magazine.chars() {\n        magazine_count[(c as u8 - b'a') as usize] += 1;\n    }\n    for c in ransom_note.chars() {\n        let index = (c as u8 - b'a') as usize;\n        if magazine_count[index] == 0 {\n            return false;\n        }\n        magazine_count[index] -= 1;\n    }\n    true\n}\n", "205": "rust\npub fn is_isomorphic(s: String, t: String) -> bool {\n    let mut s_map = [0; 128];\n    let mut t_map = [0; 128];\n\n    for (i, (&s_char, &t_char)) in s.chars().zip(t.chars()).enumerate() {\n        if s_map[s_char as usize] != 0 && s_map[s_char as usize] != t_char as usize {\n            return false;\n        }\n        if t_map[t_char as usize] != 0 && t_map[t_char as usize] != s_char as usize {\n            return false;\n        }\n\n        s_map[s_char as usize] = t_char as usize;\n        t_map[t_char as usize] = s_char as usize;\n    }\n\n    true\n}\n", "290": "rust\npub fn word_pattern(pattern: String, s: String) -> bool {\n    let pattern: Vec<char> = pattern.chars().collect();\n    let s: Vec<&str> = s.split_whitespace().collect();\n\n    if pattern.len() != s.len() {\n        return false;\n    }\n\n    let mut map = std::collections::HashMap::new();\n    let mut reverse_map = std::collections::HashMap::new();\n\n    for (i, word) in s.iter().enumerate() {\n        if !map.contains_key(&pattern[i]) && !reverse_map.contains_key(word) {\n            map.insert(pattern[i], i);\n            reverse_map.insert(word, pattern[i]);\n        } else if map.get(&pattern[i]) != Some(&i) || reverse_map.get(word) != Some(&pattern[i]) {\n            return false;\n        }\n    }\n\n    true\n}\n", "242": "rust\npub fn is_anagram(s: String, t: String) -> bool {\n    let mut s_chars: Vec<char> = s.chars().collect();\n    let mut t_chars: Vec<char> = t.chars().collect();\n\n    s_chars.sort();\n    t_chars.sort();\n\n    s_chars == t_chars\n}\n", "49": "rust\nuse std::collections::HashMap;\n\nimpl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        let mut map = HashMap::new();\n        for s in strs {\n            let mut chars = s.chars().collect::<Vec<char>>();\n            chars.sort_unstable();\n            let key = chars.into_iter().collect::<String>();\n            map.entry(key).or_insert_with(Vec::new).push(s);\n        }\n        map.into_iter().map(|(_, v)| v).collect()\n    }\n}\n", "1": "rust\npub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n    let mut map = std::collections::HashMap::new();\n    for (i, &num) in nums.iter().enumerate() {\n        let complement = target - num;\n        if let Some(&index) = map.get(&complement) {\n            return vec![index as i32, i as i32];\n        }\n        map.insert(num, i);\n    }\n    vec![]\n}\n", "202": "rust\npub fn is_happy(n: i32) -> bool {\n    let mut slow = n;\n    let mut fast = n;\n\n    while fast != 1 {\n        slow = square_digits(slow);\n        fast = square_digits(square_digits(fast));\n    }\n\n    slow == 1\n}\n\nfn square_digits(n: i32) -> i32 {\n    let mut result = 0;\n    let mut n = n;\n\n    while n > 0 {\n        let digit = n % 10;\n        result += digit * digit;\n        n /= 10;\n    }\n\n    result\n}\n", "219": "rust\npub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\n    let mut seen = std::collections::HashSet::new();\n    let mut i = 0;\n    while i < nums.len() {\n        if seen.contains(&nums[i]) {\n            return true;\n        }\n        seen.insert(nums[i]);\n        i += 1;\n        if i > k {\n            seen.remove(&nums[i - k - 1]);\n        }\n    }\n    false\n}\n", "128": "rust\npub fn longest_consecutive(nums: Vec<i32>) -> i32 {\n    let mut nums = nums;\n    nums.sort();\n    let mut longest = 1;\n    let mut current = 1;\n\n    for i in 1..nums.len() {\n        if nums[i] == nums[i - 1] {\n            continue;\n        }\n\n        if nums[i] == nums[i - 1] + 1 {\n            current += 1;\n        } else {\n            longest = longest.max(current);\n            current = 1;\n        }\n    }\n\n    longest.max(current)\n}\n", "228": "rust\npub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut start = nums[0];\n    let mut end = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        if num == end + 1 {\n            end = num;\n        } else {\n            result.push(if start == end {\n                start.to_string()\n            } else {\n                format!(\"{start}->{end}\")\n            });\n            start = num;\n            end = num;\n        }\n    }\n\n    result.push(if start == end {\n        start.to_string()\n    } else {\n        format!(\"{start}->{end}\")\n    });\n\n    result\n}\n", "56": "rust\npub fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n    intervals.sort_by_key(|interval| interval[0]);\n    let mut result = Vec::new();\n    let mut current = intervals.remove(0);\n\n    for interval in intervals {\n        if current[1] >= interval[0] {\n            current[1] = interval[1].max(current[1]);\n        } else {\n            result.push(current);\n            current = interval;\n        }\n    }\n\n    result.push(current);\n    result\n}\n", "57": "rust\npub fn insert(mut intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n    let mut new_interval = new_interval;\n    let mut i = 0;\n    while i < intervals.len() && intervals[i][1] < new_interval[0] {\n        i += 1;\n    }\n    if i > 0 {\n        new_interval[0] = intervals[i - 1][1];\n    }\n    intervals.insert(i, new_interval);\n    intervals.sort_by_key(|interval| interval[0]);\n    intervals\n}\n", "452": "rust\npub fn find_min_arrow_shots(points: Vec<Vec<i32>>) -> i32 {\n    let mut points = points;\n    points.sort_by_key(|p| p[0]);\n    let mut min_shots = 1;\n    let mut end = points[0][1];\n\n    for point in points.iter().skip(1) {\n        if point[0] > end {\n            min_shots += 1;\n            end = point[1];\n        } else {\n            end = end.min(point[1]);\n        }\n    }\n\n    min_shots\n}\n", "20": "rust\npub fn is_valid(s: String) -> bool {\n    let mut stack = Vec::new();\n\n    for c in s.chars() {\n        match c {\n            '(' | '[' | '{' => stack.push(c),\n            ')' | ']' | '}' => {\n                let last = stack.pop();\n                if last != Some(match c {\n                    ')' => '(',\n                    ']' => '[',\n                    '}' => '{',\n                    _ => unreachable!(),\n                }) {\n                    return false;\n                }\n            }\n            _ => unreachable!(),\n        }\n    }\n\n    stack.is_empty()\n}\n", "71": "rust\npub fn simplify_path(path: String) -> String {\n    let mut components = path.split('/');\n    let mut result = String::new();\n\n    for component in components {\n        match component {\n            \".\" => continue,\n            \"..\" => {\n                if !result.is_empty() {\n                    result.truncate(result.rfind('/').unwrap_or(0));\n                }\n            }\n            _ => {\n                if !result.is_empty() {\n                    result.push('/');\n                }\n                result.push_str(component);\n            }\n        }\n    }\n\n    result\n}\n", "155": "rust\nstruct MinStack {\n    stack: Vec<i32>,\n    min_stack: Vec<i32>,\n}\n\nimpl MinStack {\n    fn new() -> Self {\n        MinStack {\n            stack: Vec::new(),\n            min_stack: Vec::new(),\n        }\n    }\n\n    fn push(&mut self, val: i32) {\n        self.stack.push(val);\n        if let Some(&min) = self.min_stack.last() {\n            self.min_stack.push(min.min(val));\n        } else {\n            self.min_stack.push(val);\n        }\n    }\n\n    fn pop(&mut self) {\n        if let Some(top) = self.stack.pop() {\n            self.min_stack.pop();\n        }\n    }\n\n    fn top(&self) -> i32 {\n        *self.stack.last().unwrap()\n    }\n\n    fn get_min(&self) -> i32 {\n        *self.min_stack.last().unwrap()\n    }\n}\n", "150": "rust\npub fn eval_rpn(tokens: Vec<String>) -> i32 {\n    let mut stack = Vec::new();\n\n    for token in tokens {\n        match token.as_str() {\n            \"+\" => {\n                let b = stack.pop().unwrap();\n                let a = stack.pop().unwrap();\n                stack.push(a + b);\n            }\n            \"-\" => {\n                let b = stack.pop().unwrap();\n                let a = stack.pop().unwrap();\n                stack.push(a - b);\n            }\n            \"*\" => {\n                let b = stack.pop().unwrap();\n                let a = stack.pop().unwrap();\n                stack.push(a * b);\n            }\n            \"/\" => {\n                let b = stack.pop().unwrap();\n                let a = stack.pop().unwrap();\n                stack.push(a / b);\n            }\n            _ => {\n                let num = token.parse::<i32>().unwrap();\n                stack.push(num);\n            }\n        }\n    }\n\n    stack.pop().unwrap()\n}\n", "224": "rust\npub fn calculate(s: String) -> i32 {\n    let mut stack = Vec::new();\n    let mut num = String::new();\n    let mut sign = '+';\n\n    for c in s.chars() {\n        match c {\n            ' ' => continue,\n            '+' | '-' | '*' | '/' => {\n                if !num.is_empty() {\n                    stack.push(sign);\n                    stack.push(num.parse::<i32>().unwrap());\n                    num.clear();\n                }\n                sign = c;\n            }\n            '(' => {\n                stack.push(sign);\n                stack.push(num.parse::<i32>().unwrap());\n                num.clear();\n                sign = '+';\n            }\n            ')' => {\n                let mut result = num.parse::<i32>().unwrap();\n                num.clear();\n\n                while let Some(op) = stack.pop() {\n                    if op == '(' {\n                        break;\n                    }\n                    let num = stack.pop().unwrap();\n                    result = match op {\n                        '+' => result + num,\n                        '-' => result - num,\n                        '*' => result * num,\n                        '/' => result / num,\n                        _ => unreachable!(),\n                    };\n                }\n\n                stack.push(result);\n                sign = '+';\n            }\n            _ => num.push(c),\n        }\n    }\n\n    if !num.is_empty() {\n        stack.push(sign);\n        stack.push(num.parse::<i32>().unwrap());\n    }\n\n    while let Some(op) = stack.pop() {\n        let num = stack.pop().unwrap();\n        let result = match op {\n            '+' => num + num,\n            '-' => num - num,\n            '*' => num * num,\n            '/' => num / num,\n            _ => unreachable!(),\n        };\n        stack.push(result);\n    }\n\n    stack.pop().unwrap", "141": "rust\npub struct Solution;\n\nimpl Solution {\n    pub fn has_cycle(head: Option<Box<ListNode>>) -> bool {\n        let mut slow = head;\n        let mut fast = head;\n\n        while let Some(slow_node) = slow {\n            if let Some(fast_node) = fast {\n                if slow_node.val == fast_node.val {\n                    return true;\n                }\n            }\n\n            slow = slow_node.next;\n            fast = fast.and_then(|node| node.next);\n        }\n\n        false\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    pub fn new(val: i32) -> Self {\n        ListNode {\n            val,\n            next: None,\n        }\n    }\n}\n", "2": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut l1 = l1;\n        let mut l2 = l2;\n        let mut carry = 0;\n        let mut head = None;\n        let mut tail = &mut head;\n\n        while l1.is_some() || l2.is_some() || carry > 0 {\n            let mut sum = carry;\n            if let Some(node) = l1 {\n                sum += node.val;\n                l1 = node.next;\n            }\n            if let Some(node) = l2 {\n                sum += node.val;\n                l2 = node.next;\n            }\n\n            let mut node = ListNode::new(sum % 10);\n            *tail = Some(Box::new(node));\n            tail = &mut node.next;\n\n            carry = sum / 10;\n        }\n\n        head\n    }\n}\n", "21": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        match (list1, list2) {\n            (None, None) => None,\n            (None, Some(node)) => Some(node),\n            (Some(node), None) => Some(node),\n            (Some(node1), Some(node2)) => {\n                let mut head = if node1.val < node2.val {\n                    node1\n                } else {\n                    node2\n                };\n                let mut tail = head.clone();\n                let mut next1 = node1.next.clone();\n                let mut next2 = node2.next.clone();\n                while let (Some(node1), Some(node2)) = (next1.as_mut(), next2.as_mut()) {\n                    if node1.val < node2.val {\n                        tail.next = Some(node1.clone());\n                        tail = node1.clone();\n                        next1 = node1.next.clone();\n                    } else {\n                        tail.next = Some(node2.clone());\n                        tail = node2.clone();\n                        next2 = node2.next.clone();\n                    }\n                }\n                tail.next = next1.or(next2);\n                Some(head)\n            }\n        }\n    }\n}\n", "138": "rust\nuse std::collections::HashMap;\n\npub struct Solution;\n\nimpl Solution {\n    pub fn copy_list(head: Option<Box<Node>>) -> Option<Box<Node>> {\n        let mut map = HashMap::new();\n        let mut current = head;\n        let mut new_head = None;\n        let mut new_current = &mut new_head;\n\n        while let Some(node) = current {\n            let new_node = Box::new(Node::new(node.val));\n            map.insert(node, new_node.clone());\n            *new_current = Some(new_node);\n            new_current = &mut new_current.as_mut().unwrap().next;\n            current = node.next;\n        }\n\n        current = head;\n        new_current = &mut new_head;\n\n        while let Some(node) = current {\n            let new_node = map.get(&node).unwrap();\n            new_node.random = map.get(&node.random).cloned();\n            new_current = &mut new_current.as_mut().unwrap().next;\n            current = node.next;\n        }\n\n        new_head\n    }\n}\n\npub struct Node {\n    val: i32,\n    next: Option<Box<Node>>,\n    random: Option<Box<Node>>,\n}\n\nimpl Node {\n    pub fn new(val: i32) -> Self {\n        Node {\n            val,\n            next: None,\n            random: None,\n        }\n    }\n}\n", "92": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn reverse_between(\n        head: Option<Box<ListNode>>,\n        left: i32,\n        right: i32,\n    ) -> Option<Box<ListNode>> {\n        let mut head = head;\n        let mut prev = None;\n        let mut count = 1;\n        let mut start = None;\n        let mut end = None;\n\n        while let Some(mut node) = head {\n            if count == left {\n                start = Some(node);\n            }\n            if count == right {\n                end = Some(node);\n            }\n\n            if count > left && count <= right {\n                let next = node.next.take();\n                node.next = prev;\n                prev = Some(node);\n                head = next;\n            } else {\n                head = node.next;\n                count += 1;\n            }\n        }\n\n        if let Some(start) = start {\n            let mut start = start;\n            let mut end = end.unwrap();\n            let mut prev = prev.unwrap();\n            let mut next = start.next.take();\n\n            start.next = end.next;\n            end.next = next;\n            prev.next = Some(end);\n        }\n\n        head\n    }\n}\n", "25": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn reverse_k_group(mut head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        let mut count = 0;\n        let mut current = &mut head;\n        while let Some(node) = current {\n            count += 1;\n            current = &mut node.next;\n        }\n\n        let mut groups = count / k;\n        let mut tail = head.as_mut();\n        let mut prev = None;\n        while let Some(node) = tail {\n            let mut next = node.next.take();\n            let mut current = node;\n            for _ in 0..k {\n                let next_node = next.take();\n                current.next = next_node;\n                current = next_node.unwrap();\n            }\n            current.next = prev;\n            prev = Some(node);\n            tail = current.next.as_mut();\n            groups -= 1;\n            if groups == 0 {\n                break;\n            }\n        }\n\n        head\n    }\n}\n", "19": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Rc<RefCell<ListNode>>>,\n}\n\nimpl ListNode {\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Rc<RefCell<ListNode>>>, n: i32) -> Option<Rc<RefCell<ListNode>>> {\n        let mut dummy = Rc::new(RefCell::new(ListNode::new(0)));\n        let mut p = &dummy;\n        let mut q = &head;\n\n        for _ in 0..n {\n            q = q.as_ref()?.borrow().next.as_ref();\n        }\n\n        while q.is_some() {\n            p = p.as_ref()?.borrow().next.as_ref();\n            q = q.as_ref()?.borrow().next.as_ref();\n        }\n\n        let p = p.as_ref()?.borrow_mut().next.take();\n        dummy.as_ref()?.borrow_mut().next = p;\n\n        head\n    }\n}\n", "82": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut current = &mut head;\n        let mut previous = &mut None;\n\n        while let Some(node) = current {\n            let next = node.next.take();\n            let next_val = next.as_ref().map(|node| node.val);\n\n            if next_val != Some(node.val) {\n                *previous = Some(node);\n                current = next;\n            } else {\n                *previous = node.next.take();\n                current = previous;\n            }\n        }\n\n        head\n    }\n}\n", "61": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        let mut len = 0;\n        let mut current = head;\n        while let Some(node) = current {\n            len += 1;\n            current = node.next;\n        }\n\n        let k = k % len;\n        if k == 0 {\n            return head;\n        }\n\n        let mut current = head;\n        let mut prev = None;\n        for _ in 0..len - k {\n            prev = current;\n            current = current.as_ref().unwrap().next;\n        }\n\n        if let Some(prev) = prev {\n            prev.next = head;\n        }\n\n        current.as_mut().unwrap().next = None;\n        head\n    }\n}\n", "86": "rust\n// Definition for singly-linked list.\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: Option<Box<ListNode>>,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: None,\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn partition(mut head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        let mut less_than_x = ListNode::new(0);\n        let mut greater_than_x = ListNode::new(0);\n        let mut less_than_x_tail = &mut less_than_x;\n        let mut greater_than_x_tail = &mut greater_than_x;\n\n        while let Some(mut node) = head {\n            head = node.next.take();\n            node.next = None;\n\n            if node.val < x {\n                less_than_x_tail.next = Some(node);\n                less_than_x_tail = less_than_x_tail.next.as_mut().unwrap();\n            } else {\n                greater_than_x_tail.next = Some(node);\n                greater_than_x_tail = greater_than_x_tail.next.as_mut().unwrap();\n            }\n        }\n\n        less_than_x_tail.next = greater_than_x.next;\n        Some(less_than_x)\n    }\n}\n", "146": "rust\nuse std::collections::HashMap;\nuse std::collections::LinkedList;\n\nstruct LRUCache {\n    capacity: usize,\n    map: HashMap<i32, LinkedList<i32>>,\n    list: LinkedList<i32>,\n}\n\nimpl LRUCache {\n    fn new(capacity: i32) -> Self {\n        LRUCache {\n            capacity: capacity as usize,\n            map: HashMap::new(),\n            list: LinkedList::new(),\n        }\n    }\n\n    fn get(&mut self, key: i32) -> i32 {\n        match self.map.get(&key) {\n            Some(value) => {\n                self.list.remove(value);\n                self.list.push_front(key);\n                *value\n            }\n            None => -1,\n        }\n    }\n\n    fn put(&mut self, key: i32, value: i32) {\n        match self.map.get(&key) {\n            Some(value) => {\n                self.list.remove(value);\n                self.list.push_front(key);\n                *value = value;\n            }\n            None => {\n                if self.map.len() == self.capacity {\n                    let last = self.list.pop_back().unwrap();\n                    self.map.remove(&last);\n                }\n                self.list.push_front(key);\n                self.map.insert(key, self.list.front_mut());\n            }\n        }\n    }\n}\n", "104": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        match root {\n            None => 0,\n            Some(node) => {\n                let left_depth = Self::max_depth(node.borrow().left.clone());\n                let right_depth = Self::max_depth(node.borrow().right.clone());\n                1 + std::cmp::max(left_depth, right_depth)\n            }\n        }\n    }\n}\n", "100": "rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        match (p, q) {\n            (None, None) => true,\n            (Some(p), Some(q)) => {\n                let p = p.borrow();\n                let q = q.borrow();\n                p.val == q.val && Solution::is_same_tree(p.left.clone(), q.left.clone()) && Solution::is_same_tree(p.right.clone(), q.right.clone())\n            }\n            _ => false,\n        }\n    }\n}\n", "226": "rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        match root {\n            Some(node) => {\n                let node = node.borrow_mut();\n                let left = node.left.take();\n                let right = node.right.take();\n                node.left = Self::invert_tree(right);\n                node.right = Self::invert_tree(left);\n                Some(node.into())\n            }\n            None => None,\n        }\n    }\n}\n", "101": "rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n// Definition for a binary tree node.\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\n// Implement the Solution trait.\nimpl Solution {\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool {\n            match (left, right) {\n                (None, None) => true,\n                (Some(l), Some(r)) => {\n                    l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_deref())\n                }\n                _ => false,\n            }\n        }\n\n        is_symmetric_helper(root.as_deref(), root.as_deref())\n    }\n}\n", "105": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        let n = preorder.len();\n        if n == 0 {\n            return None;\n        }\n\n        let root_val = preorder[0];\n        let root = Rc::new(RefCell::new(TreeNode::new(root_val)));\n\n        let mut preorder_index = 1;\n        let mut inorder_index = 0;\n\n        while preorder_index < n {\n            let left_val = preorder[preorder_index];\n            let right_val = preorder[preorder_index + 1];\n\n            if left_val != inorder[inorder_index] {\n                root.borrow_mut().left = Self::build_tree(\n                    preorder[preorder_index..preorder_index + 1].to_vec(),\n                    inorder[inorder_index..inorder_index + 1].to_vec(),\n                );\n                preorder_index += 1;\n            } else {\n                root.borrow_mut().left = Self::build_tree(\n                    preorder[preorder_index..preorder_index + 1].to_vec(),\n                    inorder[inorder_index..inorder_index + 1].to_vec(),\n                );\n                preorder_index += 1;\n                inorder_index += 1;\n            }\n", "106": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        let n = inorder.len();\n        if n == 0 {\n            return None;\n        }\n\n        let root_val = postorder[n - 1];\n        let root = Rc::new(RefCell::new(TreeNode::new(root_val)));\n\n        let mut inorder_index = 0;\n        let mut postorder_index = n - 2;\n\n        while inorder_index < n && inorder[inorder_index] != root_val {\n            inorder_index += 1;\n        }\n\n        while postorder_index >= 0 && postorder[postorder_index] != root_val {\n            postorder_index -= 1;\n        }\n\n        if inorder_index < n && postorder_index >= 0 {\n            root.borrow_mut().left = Self::build_tree(\n                inorder[0..inorder_index].to_vec(),\n                postorder[0..postorder_index].to_vec(),\n            );\n            root.borrow_mut().right = Self::build_tree(\n                inorder[inorder_index + 1..n].to_vec(),\n                postorder[postorder_index + 1..n - 1].to_vec(),\n            );\n        }\n\n        Some(root)\n    }\n}\n", "117": "rust\n// Definition for a Node.\n#[derive(Debug, PartialEq, Eq)]\npub struct Node {\n    pub val: i32,\n    pub left: Option<Box<Node>>,\n    pub right: Option<Box<Node>>,\n    pub next: Option<Box<Node>>,\n}\n\nimpl Node {\n    pub fn new(val: i32) -> Self {\n        Node {\n            val,\n            left: None,\n            right: None,\n            next: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn connect(root: Option<Box<Node>>) -> Option<Box<Node>> {\n        let mut queue = vec![root];\n        while let Some(node) = queue.pop() {\n            if let Some(left) = node.left.take() {\n                queue.push(left);\n            }\n            if let Some(right) = node.right.take() {\n                queue.push(right);\n            }\n            if let Some(next) = queue.pop() {\n                node.next = Some(next);\n            }\n        }\n        root\n    }\n}\n", "114": "rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct Solution;\n\nimpl Solution {\n    pub fn flatten(root: &mut Option<Rc<RefCell<TreeNode>>>) {\n        let mut stack = vec![root];\n        let mut prev = None;\n\n        while let Some(node) = stack.pop() {\n            let node = node.as_ref().unwrap();\n            if let Some(right) = node.right.take() {\n                stack.push(node.left.take());\n                stack.push(Some(right));\n            } else {\n                if let Some(prev) = prev {\n                    prev.right = Some(node.left.take());\n                    prev.right.as_mut().unwrap().left = None;\n                }\n                prev = Some(node);\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n", "112": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> bool {\n        match root {\n            Some(node) => {\n                let node = node.borrow();\n                let val = node.val;\n                let left = node.left.clone();\n                let right = node.right.clone();\n\n                if left.is_none() && right.is_none() {\n                    return val == target_sum;\n                }\n\n                let left_sum = if let Some(left) = left {\n                    let left = left.borrow();\n                    let val = left.val;\n                    let left = left.left.clone();\n                    let right = left.right.clone();\n\n                    if left.is_none() && right.is_none() {\n                        val\n                    } else {\n                        val + Self::has_path_sum(left, target_sum - val) as i32\n                    }\n                } else {\n                    0\n                };\n\n                let right_sum = if let Some(right) = right {\n                    let right = right.borrow();\n                    let val = right.val;\n                    let left = right.left.clone();\n                    let right = right.right.clone();\n\n                    if left.is_none() && right.is_none() {\n                        val\n                    } else {\n                        val + Self::has_path_sum(right, target_", "129": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut sum = 0;\n        Self::dfs(root, &mut sum);\n        sum\n    }\n\n    fn dfs(node: Option<Rc<RefCell<TreeNode>>>, sum: &mut i32) {\n        if let Some(node) = node {\n            let node = node.borrow();\n            *sum = *sum * 10 + node.val;\n            Self::dfs(node.left.clone(), sum);\n            Self::dfs(node.right.clone(), sum);\n        }\n    }\n}\n", "124": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut max_sum = std::i32::MIN;\n        Self::dfs(root.as_ref(), &mut max_sum);\n        max_sum\n    }\n\n    fn dfs(node: Option<&Rc<RefCell<TreeNode>>>, max_sum: &mut i32) -> i32 {\n        if let Some(node) = node {\n            let node = node.borrow();\n            let left_sum = Self::dfs(node.left.as_ref(), max_sum);\n            let right_sum = Self::dfs(node.right.as_ref(), max_sum);\n            let sum = node.val + std::cmp::max(left_sum, 0) + std::cmp::max(right_sum, 0);\n            *max_sum = std::cmp::max(*max_sum, sum);\n            std::cmp::max(node.val + std::cmp::max(left_sum, 0), node.val + std::cmp::max(right_sum, 0))\n        } else {\n            0\n        }\n    }\n}\n", "173": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct BSTIterator {\n    stack: Vec<Rc<RefCell<TreeNode>>>,\n}\n\nimpl BSTIterator {\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        let mut stack = Vec::new();\n        let mut current = root;\n\n        while let Some(node) = current {\n            stack.push(node);\n            current = node.borrow().left.clone();\n        }\n\n        BSTIterator { stack }\n    }\n\n    fn next(&mut self) -> i32 {\n        let node = self.stack.pop().unwrap();\n        let mut current = node.borrow_mut();\n\n        if let Some(right) = current.right.clone() {\n            self.stack.push(right);\n        }\n\n        current.val\n    }\n\n    fn has_next(&self) -> bool {\n        !self.stack.is_empty()\n    }\n}\n", "222": "rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct Solution;\n\nimpl Solution {\n    pub fn count_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut count = 0;\n        let mut node = root;\n        while let Some(n) = node {\n            count += 1;\n            node = n.borrow().right.clone();\n        }\n        count\n    }\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n", "236": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn lowest_common_ancestor(\n        root: Option<Rc<RefCell<TreeNode>>>,\n        p: Option<Rc<RefCell<TreeNode>>>,\n        q: Option<Rc<RefCell<TreeNode>>>,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        let p_val = p.as_ref().unwrap().borrow().val;\n        let q_val = q.as_ref().unwrap().borrow().val;\n\n        if p_val > q_val {\n            Self::lowest_common_ancestor_helper(root, p, q)\n        } else {\n            Self::lowest_common_ancestor_helper(root, q, p)\n        }\n    }\n\n    fn lowest_common_ancestor_helper(\n        root: Option<Rc<RefCell<TreeNode>>>,\n        p: Option<Rc<RefCell<TreeNode>>>,\n        q: Option<Rc<RefCell<TreeNode>>>,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        if let Some(node) = root {\n            let node = node.borrow();\n            let node_val = node.val;\n\n            if node_val > p.as_ref().unwrap().borrow().val && node_val > q.as_ref().unwrap().borrow().val {\n                return Self::lowest_common_ancestor_helper(node.left.clone(), p, q);\n            }", "199": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut queue = vec![root];\n\n        while let Some(node) = queue.pop() {\n            if let Some(node) = node {\n                let node = node.borrow();\n                if result.len() == result.capacity() {\n                    result.push(node.val);\n                } else {\n                    result.insert(0, node.val);\n                }\n                queue.push(node.right.clone());\n                queue.push(node.left.clone());\n            }\n        }\n\n        result\n    }\n}\n", "637": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn average_of_levels(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<f64> {\n        let mut queue = vec![root];\n        let mut result = Vec::new();\n        while let Some(node) = queue.pop() {\n            let node = node.unwrap();\n            let val = node.borrow().val;\n            let left = node.borrow().left.clone();\n            let right = node.borrow().right.clone();\n            queue.push(left);\n            queue.push(right);\n            result.push(val as f64);\n        }\n        result.into_iter().map(|x| x as f64 / result.len() as f64).collect()\n    }\n}\n", "102": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut queue = Vec::new();\n        queue.push(root);\n\n        while let Some(node) = queue.pop() {\n            let mut level = Vec::new();\n            if let Some(node) = node {\n                level.push(node.borrow().val);\n                if let Some(left) = &node.borrow().left {\n                    queue.push(left.clone());\n                }\n                if let Some(right) = &node.borrow().right {\n                    queue.push(right.clone());\n                }\n            }\n            if !level.is_empty() {\n                result.push(level);\n            }\n        }\n\n        result\n    }\n}\n", "103": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn zigzag_level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut queue = Vec::new();\n        let mut level = 0;\n        let mut is_left_to_right = true;\n\n        queue.push(root);\n\n        while !queue.is_empty() {\n            let size = queue.len();\n            let mut level_result = Vec::new();\n\n            for _ in 0..size {\n                let node = queue.remove(0);\n\n                if let Some(node) = node {\n                    let node = node.borrow();\n\n                    if is_left_to_right {\n                        level_result.push(node.val);\n                    } else {\n                        level_result.insert(0, node.val);\n                    }\n\n                    if let Some(left) = node.left.clone() {\n                        queue.push(left);\n                    }\n\n                    if let Some(right) = node.right.clone() {\n                        queue.push(right);\n                    }\n                }\n            }\n\n            if !level_result.is_empty() {\n                result.push(level_result);\n            }\n\n            level += 1;\n            is_left_to_right = !is_left_to_right;\n        }\n\n        result\n    }\n}\n", "530": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn get_minimum_difference(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut min_diff = i32::MAX;\n        let mut prev = None;\n\n        let mut stack = vec![root];\n        while let Some(node) = stack.pop() {\n            if let Some(node) = node {\n                let node = node.borrow();\n                if let Some(prev) = prev {\n                    let prev = prev.borrow();\n                    min_diff = min_diff.min(node.val - prev.val);\n                }\n                prev = Some(node);\n\n                stack.push(node.right.clone());\n                stack.push(node.left.clone());\n            }\n        }\n\n        min_diff\n    }\n}\n", "230": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\n        let mut stack = vec![root];\n        let mut count = 0;\n        while let Some(node) = stack.pop() {\n            if let Some(node) = node {\n                let node = node.borrow();\n                stack.push(node.right.clone());\n                stack.push(node.left.clone());\n                count += 1;\n                if count == k {\n                    return node.val;\n                }\n            }\n        }\n        0\n    }\n}\n", "98": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        let mut stack = vec![];\n        let mut prev = None;\n\n        while let Some(node) = root {\n            stack.push(node);\n            root = node.borrow().left.clone();\n        }\n\n        while let Some(node) = stack.pop() {\n            let node = node.borrow();\n            if let Some(prev_node) = prev {\n                if node.val <= prev_node.val {\n                    return false;\n                }\n            }\n            prev = Some(node);\n            root = node.right.clone();\n\n            while let Some(node) = root {\n                stack.push(node);\n                root = node.borrow().left.clone();\n            }\n        }\n\n        true\n    }\n}\n", "200": "rust\npub fn num_islands(grid: Vec<Vec<char>>) -> i32 {\n    let mut count = 0;\n    let m = grid.len();\n    let n = grid[0].len();\n\n    for i in 0..m {\n        for j in 0..n {\n            if grid[i][j] == '1' {\n                count += dfs(&grid, i, j);\n            }\n        }\n    }\n\n    count\n}\n\nfn dfs(grid: &Vec<Vec<char>>, i: usize, j: usize) -> i32 {\n    let m = grid.len();\n    let n = grid[0].len();\n\n    if i >= m || j >= n || grid[i][j] == '0' {\n        return 0;\n    }\n\n    grid[i][j] = '0';\n\n    dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1)\n}\n", "130": "rust\npub fn solve(board: &mut Vec<Vec<char>>) {\n    let m = board.len();\n    let n = board[0].len();\n\n    for i in 0..m {\n        for j in 0..n {\n            if board[i][j] == 'O' {\n                dfs(board, i, j);\n            }\n        }\n    }\n}\n\nfn dfs(board: &mut Vec<Vec<char>>, i: usize, j: usize) {\n    let m = board.len();\n    let n = board[0].len();\n\n    if i < m && j < n && board[i][j] == 'O' {\n        board[i][j] = 'X';\n        dfs(board, i + 1, j);\n        dfs(board, i - 1, j);\n        dfs(board, i, j + 1);\n        dfs(board, i, j - 1);\n    }\n}\n", "133": "rust\nuse std::collections::HashMap;\n\n#[derive(Clone, Debug)]\nstruct Node {\n    val: i32,\n    neighbors: Vec<Node>,\n}\n\nimpl Node {\n    fn new(val: i32) -> Self {\n        Self {\n            val,\n            neighbors: Vec::new(),\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn clone_graph(node: Option<Box<Node>>) -> Option<Box<Node>> {\n        let mut map = HashMap::new();\n        let mut queue = vec![node];\n\n        while let Some(node) = queue.pop() {\n            let node = node.unwrap();\n            let cloned_node = Box::new(Node::new(node.val));\n            map.insert(node.val, cloned_node.clone());\n            queue.push(cloned_node);\n\n            for neighbor in node.neighbors {\n                let cloned_neighbor = map.get(&neighbor.val).unwrap();\n                cloned_node.neighbors.push(cloned_neighbor.clone());\n            }\n        }\n\n        map.get(&1).cloned()\n    }\n}\n", "399": "rust\npub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\n    let mut graph = std::collections::HashMap::new();\n    for (i, (a, b)) in equations.iter().enumerate() {\n        graph.insert((a.clone(), b.clone()), values[i]);\n        graph.insert((b.clone(), a.clone()), 1.0 / values[i]);\n    }\n\n    let mut result = Vec::new();\n    for (a, b) in queries {\n        let mut queue = std::collections::VecDeque::new();\n        queue.push_back((a.clone(), b.clone()));\n        let mut visited = std::collections::HashSet::new();\n        while let Some((node, target)) = queue.pop_front() {\n            if node == target {\n                result.push(graph[&(node, target)]);\n                break;\n            }\n            if visited.contains(&node) {\n                continue;\n            }\n            visited.insert(node.clone());\n            for &(neighbor, weight) in graph.keys() {\n                if neighbor == node {\n                    continue;\n                }\n                let new_weight = weight * graph[&(node, target)];\n                if new_weight != 0.0 {\n                    queue.push_back((neighbor.clone(), target.clone()));\n                    graph.insert((node.clone(), neighbor.clone()), new_weight);\n                    graph.insert((neighbor.clone(), node.clone()), 1.0 / new_weight);\n                }\n            }\n        }\n        if result.is_empty() {\n            result.push(-1.0);\n        }\n    }\n    result\n}\n", "207": "rust\nuse std::collections::VecDeque;\nuse std::collections::HashMap;\n\npub struct Solution;\n\nimpl Solution {\n    pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        let num_courses = num_courses as usize;\n        let mut graph = vec![Vec::new(); num_courses];\n        let mut in_degree = vec![0; num_courses];\n\n        for prerequisite in prerequisites {\n            let (course, prerequisite) = (prerequisite[0] as usize, prerequisite[1] as usize);\n            graph[prerequisite].push(course);\n            in_degree[course] += 1;\n        }\n\n        let mut queue = VecDeque::new();\n        for (i, &in_degree) in in_degree.iter().enumerate().take(num_courses) {\n            if in_degree == 0 {\n                queue.push_back(i);\n            }\n        }\n\n        let mut visited = vec![false; num_courses];\n        while let Some(course) = queue.pop_front() {\n            if visited[course] {\n                continue;\n            }\n            visited[course] = true;\n            for &neighbor in &graph[course] {\n                in_degree[neighbor] -= 1;\n                if in_degree[neighbor] == 0 {\n                    queue.push_back(neighbor);\n                }\n            }\n        }\n\n        visited.into_iter().all(|x| x)\n    }\n}\n", "210": "rust\nuse std::collections::VecDeque;\nuse std::collections::HashMap;\n\npub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n    let mut graph = HashMap::new();\n    let mut in_degree = HashMap::new();\n    let mut queue = VecDeque::new();\n\n    for course in 0..num_courses {\n        in_degree.insert(course, 0);\n    }\n\n    for prerequisite in prerequisites {\n        let course = prerequisite[0];\n        let pre_course = prerequisite[1];\n\n        graph.entry(course).or_insert_with(Vec::new).push(pre_course);\n        in_degree.insert(pre_course, in_degree[pre_course] + 1);\n    }\n\n    for (course, in_degree) in in_degree.iter() {\n        if *in_degree == 0 {\n            queue.push_back(*course);\n        }\n    }\n\n    let mut result = Vec::new();\n\n    while let Some(course) = queue.pop_front() {\n        result.push(course);\n\n        if let Some(neighbors) = graph.get(&course) {\n            for neighbor in neighbors {\n                let in_degree = in_degree.get_mut(neighbor).unwrap();\n                *in_degree -= 1;\n\n                if *in_degree == 0 {\n                    queue.push_back(*neighbor);\n                }\n            }\n        }\n    }\n\n    if result.len() == num_courses as usize {\n        result\n    } else {\n        Vec::new()\n    }\n}\n", "909": "rust\npub fn snakes_and_ladders(board: Vec<Vec<i32>>) -> i32 {\n    let n = board.len();\n    let mut moves = 0;\n    let mut curr = 1;\n\n    while curr != n * n {\n        let next = if curr + 6 <= n * n {\n            curr + 6\n        } else {\n            n * n\n        };\n\n        let dest = board[curr / n][curr % n];\n        if dest != -1 {\n            curr = dest;\n        } else {\n            curr = next;\n        }\n\n        moves += 1;\n    }\n\n    moves\n}\n", "433": "rust\npub fn min_mutation(start_gene: String, end_gene: String, bank: Vec<String>) -> i32 {\n    let start_gene = start_gene.chars().collect::<Vec<char>>();\n    let end_gene = end_gene.chars().collect::<Vec<char>>();\n    let bank = bank.iter().map(|s| s.chars().collect::<Vec<char>>()).collect::<Vec<Vec<char>>>();\n\n    let mut visited = vec![false; bank.len()];\n    let mut queue = vec![start_gene];\n    let mut steps = 0;\n\n    while let Some(curr) = queue.pop() {\n        if curr == end_gene {\n            return steps;\n        }\n\n        for i in 0..curr.len() {\n            let mut next = curr.clone();\n            next[i] = match next[i] {\n                'A' => 'C',\n                'C' => 'G',\n                'G' => 'T',\n                'T' => 'A',\n                _ => unreachable!(),\n            };\n\n            if !visited[next.iter().collect::<Vec<char>>().iter().position(|&c| c == next[i]).unwrap()] {\n                visited[next.iter().collect::<Vec<char>>().iter().position(|&c| c == next[i]).unwrap()] = true;\n                queue.push(next);\n            }\n        }\n\n        steps += 1;\n    }\n\n    -1\n}\n", "127": "rust\npub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n    let mut word_set = word_list.into_iter().collect::<std::collections::HashSet<_>>();\n    let mut queue = std::collections::VecDeque::new();\n    let mut visited = std::collections::HashSet::new();\n    let mut distance = std::collections::HashMap::new();\n\n    queue.push_back((begin_word, 1));\n    distance.insert(begin_word, 1);\n\n    while let Some((word, distance)) = queue.pop_front() {\n        if word == end_word {\n            return distance;\n        }\n\n        for i in 0..word.len() {\n            let mut neighbors = vec![];\n            let mut new_word = word.clone();\n            for c in 'a'..='z' {\n                new_word.replace_range(i..=i, &c.to_string());\n                if word_set.contains(&new_word) {\n                    neighbors.push(new_word.clone());\n                }\n            }\n\n            for neighbor in neighbors {\n                if !visited.contains(&neighbor) {\n                    visited.insert(neighbor.clone());\n                    queue.push_back((neighbor, distance + 1));\n                    distance.insert(neighbor, distance + 1);\n                }\n            }\n        }\n    }\n\n    0\n}\n", "208": "rust\npub struct Trie {\n    children: [Option<Box<Trie>>; 26],\n    is_word: bool,\n}\n\nimpl Trie {\n    pub fn new() -> Self {\n        Trie {\n            children: [None; 26],\n            is_word: false,\n        }\n    }\n\n    pub fn insert(&mut self, word: String) {\n        let mut node = self;\n        for c in word.chars() {\n            let index = c.to_ascii_lowercase() as usize - 'a' as usize;\n            if node.children[index].is_none() {\n                node.children[index] = Some(Box::new(Trie::new()));\n            }\n            node = node.children[index].as_mut().unwrap();\n        }\n        node.is_word = true;\n    }\n\n    pub fn search(&self, word: String) -> bool {\n        let mut node = self;\n        for c in word.chars() {\n            let index = c.to_ascii_lowercase() as usize - 'a' as usize;\n            if node.children[index].is_none() {\n                return false;\n            }\n            node = node.children[index].as_ref().unwrap();\n        }\n        node.is_word\n    }\n\n    pub fn starts_with(&self, prefix: String) -> bool {\n        let mut node = self;\n        for c in prefix.chars() {\n            let index = c.to_ascii_lowercase() as usize - 'a' as usize;\n            if node.children[index].is_none() {\n                return false;\n            }\n            node = node.children[index].as_ref().unwrap();\n        }\n        true\n    }\n}\n", "211": "rust\nuse std::collections::HashMap;\n\nstruct WordDictionary {\n    words: HashMap<String, bool>,\n}\n\nimpl WordDictionary {\n    fn new() -> Self {\n        WordDictionary {\n            words: HashMap::new(),\n        }\n    }\n\n    fn add_word(&mut self, word: String) {\n        self.words.insert(word, true);\n    }\n\n    fn search(&self, word: String) -> bool {\n        let mut current_word = String::new();\n        let mut chars = word.chars();\n        let mut is_match = false;\n\n        while let Some(c) = chars.next() {\n            if c == '.' {\n                current_word.push('.');\n            } else {\n                current_word.push(c);\n                is_match = self.words.contains_key(&current_word);\n                if !is_match {\n                    break;\n                }\n            }\n        }\n\n        is_match\n    }\n}\n", "212": "rust\npub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\n    let m = board.len();\n    let n = board[0].len();\n    let mut visited = vec![vec![false; n]; m];\n    let mut result = Vec::new();\n\n    for word in words {\n        let mut found = true;\n        let mut start = (0, 0);\n        let mut end = (0, 0);\n        let mut direction = (0, 0);\n\n        for (i, c) in word.chars().enumerate() {\n            let c = c as usize - 'a' as usize;\n            let row = start.0 + direction.0 * i;\n            let col = start.1 + direction.1 * i;\n\n            if row < 0 || row >= m || col < 0 || col >= n || visited[row][col] || board[row][col] as usize != c {\n                found = false;\n                break;\n            }\n\n            visited[row][col] = true;\n            start = (row, col);\n            direction = (direction.0, direction.1);\n        }\n\n        if found {\n            result.push(word);\n        }\n    }\n\n    result\n}\n", "17": "rust\npub fn letter_combinations(digits: String) -> Vec<String> {\n    let mut result = Vec::new();\n    let mapping = [\n        \"abc\",\n        \"def\",\n        \"ghi\",\n        \"jkl\",\n        \"mno\",\n        \"pqrs\",\n        \"tuv\",\n        \"wxyz\",\n    ];\n\n    for digit in digits.chars() {\n        let index = (digit as u8 - b'2') as usize;\n        let letters = mapping[index].chars().collect::<Vec<_>>();\n        let mut new_result = Vec::new();\n\n        for letter in letters {\n            for combination in result {\n                new_result.push(format!(\"{}{}\", combination, letter));\n            }\n        }\n\n        result = new_result;\n    }\n\n    result\n}\n", "77": "rust\npub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n    let n = n as usize;\n    let k = k as usize;\n    let mut result = Vec::new();\n    let mut current = Vec::new();\n    let mut used = vec![false; n];\n\n    fn dfs(n: usize, k: usize, current: &mut Vec<i32>, used: &mut Vec<bool>, result: &mut Vec<Vec<i32>>) {\n        if current.len() == k {\n            result.push(current.clone());\n            return;\n        }\n\n        for i in 0..n {\n            if !used[i] {\n                used[i] = true;\n                current.push(i as i32 + 1);\n                dfs(n, k, current, used, result);\n                used[i] = false;\n                current.pop();\n            }\n        }\n    }\n\n    dfs(n, k, &mut current, &mut used, &mut result);\n    result\n}\n", "46": "rust\npub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n    let mut result = Vec::new();\n    let mut used = vec![false; nums.len()];\n    let mut stack = Vec::new();\n\n    fn dfs(nums: &[i32], used: &mut [bool], stack: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {\n        if stack.len() == nums.len() {\n            result.push(stack.clone());\n            return;\n        }\n\n        for i in 0..nums.len() {\n            if !used[i] {\n                used[i] = true;\n                stack.push(nums[i]);\n                dfs(nums, used, stack, result);\n                used[i] = false;\n                stack.pop();\n            }\n        }\n    }\n\n    dfs(&nums, &mut used, &mut stack, &mut result);\n    result\n}\n", "39": "rust\npub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n    let mut result = Vec::new();\n    let mut current = Vec::new();\n    let mut candidates = candidates;\n    candidates.sort();\n    let mut i = 0;\n    while i < candidates.len() {\n        let candidate = candidates[i];\n        if candidate <= target {\n            current.push(candidate);\n            let mut j = i + 1;\n            while j < candidates.len() && candidates[j] == candidate {\n                j += 1;\n            }\n            let mut sub_result = combination_sum(candidates[i + 1..j].to_vec(), target - candidate);\n            for mut sub_combination in sub_result {\n                sub_combination.insert(0, candidate);\n                result.push(sub_combination);\n            }\n            i = j;\n        } else {\n            i += 1;\n        }\n    }\n    result\n}\n", "52": "rust\npub fn total_n_queens(n: i32) -> i32 {\n    let n = n as usize;\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n    for i in 1..n {\n        for j in 0..n {\n            for k in 0..i {\n                if j != k && j != i + k {\n                    dp[i][j] += dp[i - 1][k];\n                }\n            }\n        }\n    }\n    dp[n - 1][n - 1]\n}\n", "22": "rust\npub fn generate_parenthesis(n: i32) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\n    let mut push = |c: char| {\n        stack.push(c);\n    };\n\n    let mut pop = |c: char| {\n        if stack.pop().unwrap() != c {\n            return false;\n        }\n        true\n    };\n\n    let mut generate = |stack: &mut Vec<char>, result: &mut Vec<String>| {\n        if stack.is_empty() {\n            result.push(stack.iter().collect::<String>());\n        } else {\n            push('(');\n            generate(stack, result);\n            pop('(');\n            push(')');\n            generate(stack, result);\n            pop(')');\n        }\n    };\n\n    generate(&mut stack, &mut result);\n\n    result\n}\n", "79": "rust\npub fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n    let m = board.len();\n    let n = board[0].len();\n    let word_chars: Vec<char> = word.chars().collect();\n    let word_len = word_chars.len();\n\n    let mut visited = vec![vec![false; n]; m];\n\n    for i in 0..m {\n        for j in 0..n {\n            if board[i][j] == word_chars[0] {\n                if dfs(board, i, j, &word_chars, 0, &mut visited) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    false\n}\n\nfn dfs(board: &Vec<Vec<char>>, i: usize, j: usize, word: &Vec<char>, index: usize, visited: &mut Vec<Vec<bool>>) -> bool {\n    let m = board.len();\n    let n = board[0].len();\n\n    if index == word.len() {\n        return true;\n    }\n\n    if i < m && j < n && !visited[i][j] && board[i][j] == word[index] {\n        visited[i][j] = true;\n\n        if dfs(board, i + 1, j, word, index + 1, visited) ||\n            dfs(board, i - 1, j, word, index + 1, visited) ||\n            dfs(board, i, j + 1, word, index + 1, visited) ||\n            dfs(board, i, j - 1, word, index + 1, visited)\n        {\n            return true;\n        }\n\n        visited[i][j] = false;\n    }\n\n    false\n}\n", "108": "rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Eq)]\npub struct TreeNode {\n    pub val: i32,\n    pub left: Option<Rc<RefCell<TreeNode>>>,\n    pub right: Option<Rc<RefCell<TreeNode>>>,\n}\n\nimpl TreeNode {\n    #[inline]\n    pub fn new(val: i32) -> Self {\n        TreeNode {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn sorted_array_to_bst(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        let len = nums.len();\n        if len == 0 {\n            return None;\n        }\n\n        let mid = len / 2;\n        let root = Rc::new(RefCell::new(TreeNode::new(nums[mid])));\n        root.borrow_mut().left = Self::sorted_array_to_bst(nums[0..mid].to_vec());\n        root.borrow_mut().right = Self::sorted_array_to_bst(nums[mid + 1..].to_vec());\n\n        Some(root)\n    }\n}\n", "148": "rust\nuse std::cmp::Ordering;\nuse std::ptr::null_mut;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n    pub val: i32,\n    pub next: *mut ListNode,\n}\n\nimpl ListNode {\n    #[inline]\n    fn new(val: i32) -> Self {\n        ListNode {\n            next: null_mut(),\n            val,\n        }\n    }\n}\n\npub struct Solution;\n\nimpl Solution {\n    pub fn sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut head = head;\n        let mut len = 0;\n        let mut curr = head.as_deref_mut();\n        while curr.is_some() {\n            curr = curr.unwrap().next.as_deref_mut();\n            len += 1;\n        }\n\n        let mut nodes = Vec::with_capacity(len);\n        curr = head.as_deref_mut();\n        while curr.is_some() {\n            nodes.push(curr.unwrap().val);\n            curr = curr.unwrap().next.as_deref_mut();\n        }\n\n        nodes.sort_unstable();\n\n        let mut head = head;\n        let mut curr = head.as_deref_mut();\n        for val in nodes {\n            let mut new_node = Box::new(ListNode::new(val));\n            let new_node_ptr = &mut *new_node;\n            if curr.is_none() {\n                head = Some(new_node);\n                curr = head.as_deref_mut();\n            } else {\n                let next_ptr = curr.unwrap().next.as_deref_mut();\n                curr.unwrap().next = Some(new_node);\n                curr = next_ptr;\n            }\n        }\n\n        head\n    }\n}\n", "427": "rust\npub struct Solution {\n    pub root: Option<Box<Node>>,\n}\n\nimpl Solution {\n    pub fn new(grid: Vec<Vec<i32>>) -> Self {\n        let root = Self::construct_node(grid);\n        Self { root }\n    }\n\n    fn construct_node(grid: Vec<Vec<i32>>) -> Option<Box<Node>> {\n        let n = grid.len();\n        if n == 1 {\n            Some(Box::new(Node {\n                val: grid[0][0] == 1,\n                is_leaf: true,\n                top_left: None,\n                top_right: None,\n                bottom_left: None,\n                bottom_right: None,\n            }))\n        } else {\n            let top_left = Self::construct_node(grid[0..n / 2].to_vec());\n            let top_right = Self::construct_node(grid[n / 2..n].to_vec());\n            let bottom_left = Self::construct_node(grid[n / 2..n].to_vec());\n            let bottom_right = Self::construct_node(grid[n / 2..n].to_vec());\n\n            let mut is_leaf = true;\n            let mut val = grid[0][0];\n            for i in 0..n {\n                for j in 0..n {\n                    if grid[i][j] != val {\n                        is_leaf = false;\n                        break;\n                    }\n                }\n            }\n\n            Some(Box::new(Node {\n                val: val == 1,\n                is_leaf,\n                top_left,\n                top_right,\n                bottom_left,\n                bottom_right,\n            }))\n        }\n    }\n}\n\npub struct Node {\n    pub val: bool,\n    pub is_leaf: bool,\n    pub top_left: Option<Box<Node>>,\n    pub top_right: Option<Box<Node>>,\n    pub bottom_left: Option<Box<Node>>,\n    pub bottom_right: Option<Box<Node>>,\n}\n", "23": "rust\nuse std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\npub struct Solution;\n\nimpl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        let mut heap = BinaryHeap::new();\n        for list in lists {\n            if let Some(node) = list {\n                heap.push(Reverse(node));\n            }\n        }\n\n        let mut head = None;\n        let mut tail = &mut head;\n\n        while let Some(Reverse(node)) = heap.pop() {\n            let node = node.into_inner();\n            *tail = Some(node);\n            tail = &mut node.next;\n\n            if let Some(next) = node.next {\n                heap.push(Reverse(next));\n            }\n        }\n\n        head\n    }\n}\n", "53": "rust\npub fn max_sub_array(nums: Vec<i32>) -> i32 {\n    let mut max_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for i in 1..nums.len() {\n        current_sum = std::cmp::max(nums[i], current_sum + nums[i]);\n        max_sum = std::cmp::max(max_sum, current_sum);\n    }\n\n    max_sum\n}\n", "918": "rust\npub fn max_subarray_sum_circular(nums: Vec<i32>) -> i32 {\n    let n = nums.len();\n    let mut max_sum = nums[0];\n    let mut max_sum_with_current = nums[0];\n    let mut min_sum_with_current = nums[0];\n\n    for i in 1..n {\n        max_sum_with_current = max_sum_with_current.max(nums[i]);\n        max_sum = max_sum.max(max_sum_with_current - min_sum_with_current);\n        min_sum_with_current = min_sum_with_current.min(nums[i]);\n    }\n\n    max_sum\n}\n", "35": "rust\npub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n    let mut low = 0;\n    let mut high = nums.len() as i32 - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        match nums[mid as usize].cmp(&target) {\n            std::cmp::Ordering::Less => low = mid + 1,\n            std::cmp::Ordering::Greater => high = mid - 1,\n            std::cmp::Ordering::Equal => return mid,\n        }\n    }\n\n    low.max(0).min(nums.len() as i32 - 1)\n}\n", "74": "rust\npub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n    let (m, n) = (matrix.len(), matrix[0].len());\n    let mut left = 0;\n    let mut right = m * n - 1;\n\n    while left <= right {\n        let mid = left + (right - left) / 2;\n        let (i, j) = (mid / n, mid % n);\n\n        if matrix[i][j] == target {\n            return true;\n        } else if matrix[i][j] > target {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    false\n}\n", "162": "rust\npub fn find_peak_element(nums: Vec<i32>) -> i32 {\n    let n = nums.len();\n    let mut left = 0;\n    let mut right = n - 1;\n\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if nums[mid] < nums[mid + 1] {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    left\n}\n", "33": "rust\npub fn search(nums: &[i32], target: i32) -> i32 {\n    let (mut left, mut right) = (0, nums.len() - 1);\n    while left <= right {\n        let mid = left + (right - left) / 2;\n        match nums[mid].cmp(&target) {\n            std::cmp::Ordering::Less => left = mid + 1,\n            std::cmp::Ordering::Greater => right = mid - 1,\n            std::cmp::Ordering::Equal => return mid as i32,\n        }\n    }\n    -1\n}\n", "34": "rust\npub fn search_range(nums: &[i32], target: i32) -> Vec<i32> {\n    let mut left = 0;\n    let mut right = nums.len() - 1;\n\n    while left <= right {\n        let mid = left + (right - left) / 2;\n        match nums[mid].cmp(&target) {\n            std::cmp::Ordering::Less => left = mid + 1,\n            std::cmp::Ordering::Greater => right = mid - 1,\n            std::cmp::Ordering::Equal => {\n                let mut left_bound = mid;\n                while left_bound > 0 && nums[left_bound - 1] == target {\n                    left_bound -= 1;\n                }\n                let mut right_bound = mid;\n                while right_bound < nums.len() - 1 && nums[right_bound + 1] == target {\n                    right_bound += 1;\n                }\n                return vec![left_bound as i32, right_bound as i32];\n            }\n        }\n    }\n\n    vec![-1, -1]\n}\n", "153": "rust\npub fn find_min(nums: Vec<i32>) -> i32 {\n    let n = nums.len();\n    let mut left = 0;\n    let mut right = n - 1;\n\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if nums[mid] > nums[right] {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    nums[left]\n}\n", "4": "rust\npub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n    let mut nums = [0; 2001];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let m = nums1.len();\n    let n = nums2.len();\n    let total = m + n;\n\n    while i < m && j < n {\n        if nums1[i] <= nums2[j] {\n            nums[k] = nums1[i];\n            i += 1;\n        } else {\n            nums[k] = nums2[j];\n            j += 1;\n        }\n        k += 1;\n    }\n\n    while i < m {\n        nums[k] = nums1[i];\n        i += 1;\n        k += 1;\n    }\n\n    while j < n {\n        nums[k] = nums2[j];\n        j += 1;\n        k += 1;\n    }\n\n    if total % 2 == 0 {\n        (nums[total / 2 - 1] as f64 + nums[total / 2] as f64) / 2.0\n    } else {\n        nums[total / 2] as f64\n    }\n}\n", "215": "rust\npub fn find_kth_largest(nums: Vec<i32>, k: i32) -> i32 {\n    let k = k as usize - 1;\n    let mut nums = nums;\n    nums.sort_unstable_by(|a, b| b.cmp(a));\n    nums[k]\n}\n", "502": "rust\npub fn find_maximized_capital(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {\n    let mut max_capital = w;\n    let mut projects = vec![0; k as usize];\n    let mut i = 0;\n    while i < k as usize {\n        let mut min_capital = i32::MAX;\n        let mut min_index = -1;\n        for j in 0..capital.len() {\n            if projects[j as usize] == 0 && capital[j as usize] < min_capital {\n                min_capital = capital[j as usize];\n                min_index = j as i32;\n            }\n        }\n        if min_index != -1 {\n            projects[min_index as usize] = 1;\n            max_capital += profits[min_index as usize];\n        } else {\n            break;\n        }\n        i += 1;\n    }\n    max_capital\n}\n", "373": "rust\npub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\n    let mut pairs = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut sum = 0;\n    let mut k = k as usize;\n\n    while i < nums1.len() && j < nums2.len() && k > 0 {\n        sum = nums1[i] + nums2[j];\n        pairs.push(vec![nums1[i], nums2[j]]);\n        i += 1;\n        j += 1;\n        k -= 1;\n    }\n\n    pairs\n}\n", "295": "rust\nstruct MedianFinder {\n    nums: Vec<i32>,\n    size: usize,\n}\n\nimpl MedianFinder {\n    fn new() -> Self {\n        MedianFinder {\n            nums: Vec::new(),\n            size: 0,\n        }\n    }\n\n    fn add_num(&mut self, num: i32) {\n        self.nums.push(num);\n        self.size += 1;\n    }\n\n    fn find_median(&self) -> f64 {\n        let mid = self.size / 2;\n        let (mut left, mut right) = (0, self.size - 1);\n        while left < right {\n            let mid_left = left + (right - left) / 2;\n            let mid_right = right - (right - left) / 2;\n            if self.nums[mid_left] > self.nums[mid_right] {\n                right = mid_left;\n            } else {\n                left = mid_right;\n            }\n        }\n        if self.size % 2 == 0 {\n            (self.nums[left] as f64 + self.nums[right] as f64) / 2.0\n        } else {\n            self.nums[left] as f64\n        }\n    }\n}\n", "67": "rust\npub fn add_binary(a: String, b: String) -> String {\n    let mut result = String::new();\n    let mut carry = 0;\n\n    let a_chars: Vec<char> = a.chars().collect();\n    let b_chars: Vec<char> = b.chars().collect();\n\n    let mut a_index = a_chars.len() - 1;\n    let mut b_index = b_chars.len() - 1;\n\n    while a_index >= 0 || b_index >= 0 || carry > 0 {\n        let a_digit = if a_index >= 0 { a_chars[a_index] } else { '0' };\n        let b_digit = if b_index >= 0 { b_chars[b_index] } else { '0' };\n\n        let sum = (a_digit.to_digit(10).unwrap() + b_digit.to_digit(10).unwrap() + carry) % 2;\n        result.insert(0, sum.to_string().chars().next().unwrap());\n\n        carry = (a_digit.to_digit(10).unwrap() + b_digit.to_digit(10).unwrap() + carry) / 2;\n\n        a_index -= 1;\n        b_index -= 1;\n    }\n\n    result\n}\n", "190": "rust\npub fn reverse_bits(mut x: u32) -> u32 {\n    x = x.reverse_bits();\n    x >>= 1;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x\n}\n", "191": "rust\npub fn hamming_weight(n: i32) -> i32 {\n    let mut count = 0;\n    let mut num = n;\n\n    while num > 0 {\n        count += num & 1;\n        num >>= 1;\n    }\n\n    count\n}\n", "136": "rust\npub fn single_number(nums: Vec<i32>) -> i32 {\n    let mut result = 0;\n    for &num in nums.iter() {\n        result ^= num;\n    }\n    result\n}\n", "137": "rust\npub fn single_number(nums: Vec<i32>) -> i32 {\n    let mut xor = 0;\n    for &num in nums.iter() {\n        xor ^= num;\n    }\n    xor\n}\n", "201": "rust\npub fn range_bitwise_and(left: i32, right: i32) -> i32 {\n    let mut result = 0;\n    let mut i = left;\n    while i <= right {\n        result |= i;\n        i += 1;\n    }\n    result\n}\n", "9": "rust\npub fn is_palindrome(x: i32) -> bool {\n    let mut num = x;\n    let mut reversed = 0;\n\n    while num > 0 {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n\n    x == reversed\n}\n", "66": "rust\npub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\n    let mut carry = 1;\n    for digit in digits.iter_mut().rev() {\n        let sum = *digit + carry;\n        *digit = sum % 10;\n        carry = sum / 10;\n        if carry == 0 {\n            break;\n        }\n    }\n    if carry > 0 {\n        digits.insert(0, carry);\n    }\n    digits\n}\n", "172": "rust\npub fn trailing_zeroes(n: i32) -> i32 {\n    let mut count = 0;\n    let mut factorial = 1;\n    while factorial <= n {\n        factorial *= factorial;\n        count += factorial / 10;\n    }\n    count\n}\n", "69": "rust\npub fn my_sqrt(x: i32) -> i32 {\n    let mut low = 0;\n    let mut high = x;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        let mid_sq = mid * mid;\n\n        if mid_sq > x {\n            high = mid - 1;\n        } else if mid_sq < x {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n\n    low - 1\n}\n", "50": "rust\npub fn my_pow(x: f64, n: i32) -> f64 {\n    x.powf(n as f64)\n}\n", "149": "rust\nuse std::collections::HashMap;\n\nimpl Solution {\n    pub fn max_points(points: Vec<Vec<i32>>) -> i32 {\n        let mut map = HashMap::new();\n        let mut max_points = 0;\n\n        for point in points {\n            let slope = Self::get_slope(point[0], point[1]);\n            let count = map.entry(slope).or_insert(0);\n            *count += 1;\n            max_points = max_points.max(*count);\n        }\n\n        max_points\n    }\n\n    fn get_slope(x1: i32, y1: i32) -> i32 {\n        if x1 == y1 {\n            return 0;\n        }\n        if x1 < y1 {\n            return 1;\n        }\n        -1\n    }\n}\n", "70": "rust\npub fn climb_stairs(n: i32) -> i32 {\n    let mut memo = vec![0; n as usize + 1];\n    memo[0] = 1;\n    memo[1] = 1;\n\n    for i in 2..=n {\n        memo[i as usize] = memo[(i - 1) as usize] + memo[(i - 2) as usize];\n    }\n\n    memo[n as usize]\n}\n", "198": "rust\npub fn rob(nums: Vec<i32>) -> i32 {\n    let n = nums.len();\n    let mut dp = vec![0; n + 1];\n    dp[0] = 0;\n    dp[1] = nums[0];\n\n    for i in 2..=n {\n        dp[i] = dp[i - 1].max(dp[i - 2] + nums[i - 1]);\n    }\n\n    dp[n]\n}\n", "139": "rust\npub fn word_break(s: String, word_dict: Vec<String>) -> bool {\n    let s = s.as_str();\n    let word_dict: Vec<&str> = word_dict.iter().map(|s| s.as_str()).collect();\n    let mut dp = vec![false; s.len() + 1];\n    dp[0] = true;\n\n    for i in 1..=s.len() {\n        for j in 1..=i {\n            if dp[j - 1] && word_dict.contains(&&s[j - i..j]) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    dp[s.len()]\n}\n", "322": "rust\npub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n    let mut dp = vec![amount + 1; amount as usize + 1];\n    dp[0] = 0;\n\n    for coin in coins {\n        for i in (coin..=amount).rev() {\n            dp[i as usize] = dp[i as usize].min(dp[(i - coin) as usize] + 1);\n        }\n    }\n\n    if dp[amount as usize] > amount {\n        -1\n    } else {\n        dp[amount as usize]\n    }\n}\n", "300": "rust\npub fn length_of_lis(nums: Vec<i32>) -> i32 {\n    let mut dp = vec![1; nums.len()];\n    let mut max_len = 1;\n\n    for i in 1..nums.len() {\n        for j in 0..i {\n            if nums[i] > nums[j] {\n                dp[i] = dp[j].max(dp[i]);\n            }\n        }\n        max_len = max_len.max(dp[i] + 1);\n    }\n\n    max_len\n}\n", "120": "rust\npub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n    let mut dp = vec![0; triangle.len()];\n    for row in triangle.iter().rev() {\n        for i in 0..row.len() {\n            dp[i] = dp[i].min(dp[i + 1]).max(row[i]);\n        }\n    }\n    dp[0]\n}\n", "64": "rust\npub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {\n    let m = grid.len();\n    let n = grid[0].len();\n\n    let mut dp = vec![vec![0; n]; m];\n\n    for i in 0..m {\n        for j in 0..n {\n            if i == 0 && j == 0 {\n                dp[i][j] = grid[i][j];\n            } else if i == 0 {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n            } else {\n                dp[i][j] = std::cmp::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n\n    dp[m - 1][n - 1]\n}\n", "63": "rust\npub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n    let m = obstacle_grid.len();\n    let n = obstacle_grid[0].len();\n    let mut dp = vec![vec![0; n]; m];\n\n    for i in 0..m {\n        for j in 0..n {\n            if obstacle_grid[i][j] == 1 {\n                dp[i][j] = 0;\n            } else if i == 0 && j == 0 {\n                dp[i][j] = 1;\n            } else if i == 0 {\n                dp[i][j] = dp[i][j - 1];\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[m - 1][n - 1]\n}\n", "5": "rust\npub fn longest_palindrome(s: String) -> String {\n    let s = s.as_str();\n    let len = s.len();\n    let mut longest = String::new();\n    let mut start = 0;\n    let mut end = 0;\n\n    for i in 0..len {\n        let (left, right) = (i, i);\n        while left >= 0 && right < len && s.chars().nth(left).unwrap() == s.chars().nth(right).unwrap() {\n            if right - left + 1 > longest.len() {\n                longest = s[left..=right].to_string();\n            }\n            left -= 1;\n            right += 1;\n        }\n\n        let (left, right) = (i, i + 1);\n        while left >= 0 && right < len && s.chars().nth(left).unwrap() == s.chars().nth(right).unwrap() {\n            if right - left + 1 > longest.len() {\n                longest = s[left..=right].to_string();\n            }\n            left -= 1;\n            right += 1;\n        }\n    }\n\n    longest\n}\n", "97": "rust\npub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n    let s1 = s1.chars().collect::<Vec<char>>();\n    let s2 = s2.chars().collect::<Vec<char>>();\n    let s3 = s3.chars().collect::<Vec<char>>();\n\n    let n = s1.len();\n    let m = s2.len();\n\n    if n + m != s3.len() {\n        return false;\n    }\n\n    let mut dp = vec![vec![false; m + 1]; n + 1];\n\n    dp[0][0] = true;\n\n    for i in 1..=n {\n        for j in 1..=m {\n            if i == 1 && j == 1 {\n                dp[i][j] = s1[0] == s3[0] && s2[0] == s3[1];\n            } else if i == 1 {\n                dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[j - 1];\n            } else if j == 1 {\n                dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i - 1];\n            } else {\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[j - 1]);\n            }\n        }\n    }\n\n    dp[n][m]\n}\n", "72": "rust\npub fn min_distance(word1: String, word2: String) -> i32 {\n    let mut dp = vec![vec![0; word2.len() + 1]; word1.len() + 1];\n\n    for i in 1..=word1.len() {\n        for j in 1..=word2.len() {\n            if word1.chars().nth(i - 1) == word2.chars().nth(j - 1) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                dp[i][j] = dp[i][j].min(dp[i - 1][j] + 1);\n                dp[i][j] = dp[i][j].min(dp[i][j - 1] + 1);\n            }\n        }\n    }\n\n    dp[word1.len()][word2.len()]\n}\n", "123": "rust\npub fn max_profit(prices: Vec<i32>) -> i32 {\n    let mut min_price = i32::MAX;\n    let mut max_profit = 0;\n\n    for &price in prices.iter() {\n        min_price = min_price.min(price);\n        max_profit = max_profit.max(price - min_price);\n    }\n\n    max_profit\n}\n", "188": "rust\npub fn max_profit(k: i32, prices: Vec<i32>) -> i32 {\n    let k = k as usize;\n    let mut max_profit = 0;\n    let mut min_price = i32::MAX;\n\n    for &price in prices.iter() {\n        if price < min_price {\n            min_price = price;\n        } else if price - min_price > max_profit {\n            max_profit = price - min_price;\n        }\n    }\n\n    if k > 1 {\n        let mut max_profit_with_k_transactions = 0;\n        let mut min_price_with_k_transactions = i32::MAX;\n\n        for &price in prices.iter() {\n            if price < min_price_with_k_transactions {\n                min_price_with_k_transactions = price;\n            } else if price - min_price_with_k_transactions > max_profit_with_k_transactions {\n                max_profit_with_k_transactions = price - min_price_with_k_transactions;\n            }\n        }\n\n        max_profit = max_profit.max(max_profit_with_k_transactions);\n    }\n\n    max_profit\n}\n", "221": "rust\npub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\n    let m = matrix.len();\n    let n = matrix[0].len();\n    let mut dp = vec![vec![0; n + 1]; m + 1];\n    let mut max_square = 0;\n\n    for i in 1..=m {\n        for j in 1..=n {\n            if matrix[i - 1][j - 1] == '1' {\n                dp[i][j] = std::cmp::min(dp[i - 1][j], dp[i][j - 1]).max(dp[i - 1][j - 1]) + 1;\n                max_square = std::cmp::max(max_square, dp[i][j]);\n            }\n        }\n    }\n\n    max_square\n}\n"}