{"88": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 5: Char 21: error: mismatched types (solution.rs) | 5 | let mut k = m + n as usize - 1; | ^^^^^^^^^^ expected `i32`, found `usize` Line 5: Char 19: error: cannot add `usize` to `i32` (solution.rs) | 5 | let mut k = m + n as usize - 1; | ^ no implementation for `i32 + usize` | = help: the trait `Add<usize>` is not implemented for `i32` = help: the following other types implement trait `Add<Rhs>`: <i32 as Add> <i32 as Add<&i32>> <&'a i32 as Add<i32>> <&i32 as Add<&i32>> Line 9: Char 19: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 9 | nums1[k] = nums1[i]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 12: Char 19: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 12 | nums1[k] = nums2[j]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Line 19: Char 15: error: the type `[i32]` cannot be indexed by `i32` (solution.rs) | 19 | nums1[k] = nums2[j]; | ^ slice indices are of type `usize` or ranges of `usize` | = help: the trait `SliceIndex<[i32]>` is not implemented for `i32` = help: the trait `SliceIndex<[T]>` is implemented for `usize` = note: required for `Vec<i32>` to implement `std::ops::Index<i32>` Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 5 previous errors"}, "27": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 5: error: mismatched types (solution.rs) | 2 | pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 { | --- expected `i32` because of return type ... 10 | k | ^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 10 | k.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "26": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "80": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "169": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "189": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "121": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "122": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "55": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "45": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "274": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "380": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "238": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "134": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 24: Char 16: error: mismatched types (solution.rs) | 2 | pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 24 | return start; | ^^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 24 | return start.try_into().unwrap(); | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "135": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 17: Char 32: index out of bounds: the len is 3 but the index is 3 (solution.rs)"}, "42": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "13": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "12": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "58": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "14": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "151": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 10: error: mismatched types (solution.rs) | 13 | *s = reversed_string; | -- ^^^^^^^^^^^^^^^ expected `str`, found `String` | | | expected due to the type of this binding Line 2: Char 40: error: mismatched types (solution.rs) | 2 | pub fn reverse_words(s: String) -> String { | ------------- ^^^^^^ expected `String`, found `()` | | | implicitly returns `()` as its body has no tail or `return` expression | Line 2: Char 26: note: consider returning one of these bindings (solution.rs) | 2 | pub fn reverse_words(s: String) -> String { | ^ ... 5 | let mut reversed_string = String::new(); | ^^^^^^^^^^^^^^^ Line 13: Char 5: error: the size for values of type `str` cannot be known at compilation time (solution.rs) | 13 | *s = reversed_string; | ^^ doesn't have a size known at compile-time | = help: the trait `Sized` is not implemented for `str` = note: the left-hand-side of an assignment must have a statically known size Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "6": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "28": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "68": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "125": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "392": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "167": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 9: Char 49: error: mismatched types (solution.rs) | 9 | std::cmp::Ordering::Equal => return Some([left + 1, right + 1]), | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Vec<i32>`, found `Option<[usize; 2]>` | = note: expected struct `Vec<i32>` found enum `Option<[usize; 2]>` Line 12: Char 5: error: mismatched types (solution.rs) | 2 | pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> { | -------- expected `Vec<i32>` because of return type ... 12 | None | ^^^^ expected `Vec<i32>`, found `Option<_>` | = note: expected struct `Vec<i32>` found enum `Option<_>` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "11": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "15": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "209": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 11: Char 35: error: mismatched types (solution.rs) | 11 | min_len = min_len.min(end - start + 1); | --- ^^^^^^^^^^^^^^^ expected `i32`, found `usize` | | | arguments to this method are incorrect | Line 11: Char 23: help: the return type of this call is `usize` due to the type of the argument passed (solution.rs) | 11 | min_len = min_len.min(end - start + 1); | ^^^^^^^^^^^^---------------^ | | | this argument influences the return type of `min` Line 827: Char 8: note: method defined here (solution.rs) help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 11 | min_len = min_len.min((end - start + 1).try_into().unwrap()); | + +++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "3": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "30": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "76": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "36": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 31: Char 13: error: expected pattern, found keyword `in` (solution.rs) | 31 | for box in boxes.iter() { | ^^ expected pattern Line 20: Char 16: error: no method named `count_ones` found for reference `&{integer}` in the current scope (solution.rs) | 20 | if row.count_ones() != 9 { | ^^^^^^^^^^ method not found in `&{integer}` Line 26: Char 16: error: no method named `count_ones` found for reference `&{integer}` in the current scope (solution.rs) | 26 | if col.count_ones() != 9 { | ^^^^^^^^^^ method not found in `&{integer}` For more information about this error, try `rustc --explain E0599`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "54": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 24: Char 43: index out of bounds: the len is 1 but the index is 18446744073709551615 (solution.rs)"}, "48": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "73": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "289": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 8: Char 29: error: cannot find function `count_neighbors` in this scope (solution.rs) | 8 | let neighbors = count_neighbors(board, i, j); | ^^^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 8 | let neighbors = Self::count_neighbors(board, i, j); | ++++++ For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "383": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "205": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 6: Char 14: error: mismatched types (solution.rs) | 6 | for (i, (&s_char, &t_char)) in s.chars().zip(t.chars()).enumerate() { | ^^^^^^^ ------------------------------------ this is an iterator with items of type `(usize, (char, char))` | | | expected `char`, found `&_` | = note: expected type `char` found reference `&_` help: consider removing `&` from the pattern | 7 - for (i, (&s_char, &t_char)) in s.chars().zip(t.chars()).enumerate() { 7 + for (i, (s_char, &t_char)) in s.chars().zip(t.chars()).enumerate() { | Line 6: Char 23: error: mismatched types (solution.rs) | 6 | for (i, (&s_char, &t_char)) in s.chars().zip(t.chars()).enumerate() { | ^^^^^^^ ------------------------------------ this is an iterator with items of type `(usize, (char, char))` | | | expected `char`, found `&_` | = note: expected type `char` found reference `&_` help: consider removing `&` from the pattern | 7 - for (i, (&s_char, &t_char)) in s.chars().zip(t.chars()).enumerate() { 7 + for (i, (&s_char, t_char)) in s.chars().zip(t.chars()).enumerate() { | For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "290": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "242": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "49": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "1": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "202": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 7: Char 16: error: cannot find function `square_digits` in this scope (solution.rs) | 7 | slow = square_digits(slow); | ^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 7 | slow = Self::square_digits(slow); | ++++++ Line 8: Char 30: error: cannot find function `square_digits` in this scope (solution.rs) | 8 | fast = square_digits(square_digits(fast)); | ^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 8 | fast = square_digits(Self::square_digits(fast)); | ++++++ Line 8: Char 16: error: cannot find function `square_digits` in this scope (solution.rs) | 8 | fast = square_digits(square_digits(fast)); | ^^^^^^^^^^^^^ not found in this scope | help: consider using the associated function on `Self` | 8 | fast = Self::square_digits(square_digits(fast)); | ++++++ For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "219": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 11: Char 16: error: mismatched types (solution.rs) | 11 | if i > k { | - ^ expected `usize`, found `i32` | | | expected because this is `usize` | help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit | 11 | if i > k.try_into().unwrap() { | ++++++++++++++++++++ Line 12: Char 35: error: mismatched types (solution.rs) | 12 | seen.remove(&nums[i - k - 1]); | ^ expected `usize`, found `i32` Line 12: Char 33: error: cannot subtract `i32` from `usize` (solution.rs) | 12 | seen.remove(&nums[i - k - 1]); | ^ no implementation for `usize - i32` | = help: the trait `Sub<i32>` is not implemented for `usize` = help: the following other types implement trait `Sub<Rhs>`: <usize as Sub> <usize as Sub<&usize>> <&'a usize as Sub<usize>> <&usize as Sub<&usize>> Some errors have detailed explanations: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "128": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "228": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 4: Char 25: index out of bounds: the len is 0 but the index is 0 (solution.rs)"}, "56": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 2: Char 18: error: cannot borrow `intervals` as mutable, as it is not declared as mutable (solution.rs) | 2 | pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> { | ^^^^^^^^^ not mutable 3 | intervals.sort_by_key(|interval| interval[0]); | --------- cannot borrow as mutable 4 | let mut result = Vec::new(); 5 | let mut current = intervals.remove(0); | --------- cannot borrow as mutable | help: consider changing this to be mutable | 2 | pub fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> { | +++ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "57": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 2: Char 19: error: cannot borrow `intervals` as mutable, as it is not declared as mutable (solution.rs) | 2 | pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> { | ^^^^^^^^^ not mutable ... 11 | intervals.insert(i, new_interval); | --------- cannot borrow as mutable 12 | intervals.sort_by_key(|interval| interval[0]); | --------- cannot borrow as mutable | help: consider changing this to be mutable | 2 | pub fn insert(mut intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> { | +++ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "452": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "20": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "71": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "155": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "150": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "224": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 32: error: mismatched types (solution.rs) | 12 | stack.push(sign); | ----- ---- this argument has type `char`... | | | ... which causes `stack` to have type `Vec<char>` 13 | stack.push(num.parse::<i32>().unwrap()); | ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `i32` | | | arguments to this method are incorrect | Line 1877: Char 12: note: method defined here (solution.rs) Line 20: Char 28: error: mismatched types (solution.rs) | 12 | stack.push(sign); | ----- ---- this argument has type `char`... | | | ... which causes `stack` to have type `Vec<char>` ... 20 | stack.push(num.parse::<i32>().unwrap()); | ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `i32` | | | arguments to this method are incorrect | Line 1877: Char 12: note: method defined here (solution.rs) Line 34: Char 39: error: cannot add `char` to `i32` (solution.rs) | 34 | '+' => result + num, | ^ no implementation for `i32 + char` | = help: the trait `Add<char>` is not implemented for `i32` = help: the following other types implement trait `Add<Rhs>`: <i32 as Add> <i32 as Add<&i32>> <&'a i32 as Add<i32>> <&i32 as Add<&i32>> Line 35: Char 39: error: cannot subtract `char` from `i32` (solution.rs) | 35 | '-' => result - num, | ^ no implementation for `i32 - char` | = help: the trait `Sub<char>` is not implemented for `i32` = help: the following other types implement trait `Sub<Rhs>`: <i32 as Sub> <i32 as Sub<&i32>> <&'a i32 as Sub<i32>> <&i32 as Sub<&i32>> Line 36: Char 39: error: cannot multiply `i32` by `char` (solution.rs) | 36 | '*' => result * num, | ^ no implementation for `i32 * char` | = help: the trait `Mul<char>` is not implemented for `i32` = help: the following other types implement trait `Mul<Rhs>`: <i32 as Mul> <i32 as Mul<&i32>> <&'a i32 as Mul<i32>> <&i32 as Mul<&i32>> Line 37: Char 39: error: cannot divide `i32` by `char` (solution.rs) | 37 | '/' => result / num, | ^ no implementation for `i32 / char` | = help: the trait `Div<char>` is not implemented for `i32` = help: the following other types implement trait `Div<Rhs>`: <i32 as Div> <i32 as Div<&i32>> <&'a i32 as Div<i32>> <&i32 as Div<&i32>> Line 42: Char 28: error: mismatched types (solution.rs) | 12 | stack.push(sign); | ----- ---- this argument has type `char`... | | | ... which causes `stack` to have type `Vec<char>` ... 42 | stack.push(result); | ---- ^^^^^^ expected `char`, found `i32` | | | arguments to this method are incorrect | Line 1877: Char 12: note: method defined here (solution.rs) Line 51: Char 20: error: mismatched types (solution.rs) | 12 | stack.push(sign); | ----- ---- this argument has type `char`... | | | ... which causes `stack` to have type `Vec<char>` ... 51 | stack.push(num.parse::<i32>().unwrap()); | ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `i32` | | | arguments to this method are incorrect | Line 1877: Char 12: note: method defined here (solution.rs) Line 57: Char 24: error: cannot add `char` to `char` (solution.rs) | 57 | '+' => num + num, | --- ^ --- char | | | char Line 58: Char 24: error: cannot subtract `char` from `char` (solution.rs) | 58 | '-' => num - num, | --- ^ --- char | | | char Line 59: Char 24: error: cannot multiply `char` by `char` (solution.rs) | 59 | '*' => num * num, | --- ^ --- char | | | char Line 60: Char 24: error: cannot divide `char` by `char` (solution.rs) | 60 | '/' => num / num, | --- ^ --- char | | | char Line 66: Char 17: error: no field `unwrap` on type `Option<char>` (solution.rs) | 66 | stack.pop().unwrap | ^^^^^^ Some errors have detailed explanations: E0277, E0308, E0369, E0609. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 13 previous errors"}, "141": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "2": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 38: Char 20: error: `node.next` does not live long enough (solution.rs) | 36 | let mut node = ListNode::new(sum % 10); | -------- binding `node` declared here 37 | *tail = Some(Box::new(node)); | ----- borrow later used here 38 | tail = &mut node.next; | ^^^^^^^^^^^^^^ borrowed value does not live long enough ... 41 | } | - `node.next` dropped here while still borrowed Line 38: Char 20: error: borrow of moved value: `node` (solution.rs) | 36 | let mut node = ListNode::new(sum % 10); | -------- move occurs because `node` has type `list_node::ListNode`, which does not implement the `Copy` trait 37 | *tail = Some(Box::new(node)); | ---- value moved here 38 | tail = &mut node.next; | ^^^^^^^^^^^^^^ value borrowed here after move | help: consider cloning the value if the performance cost is acceptable | 37 | *tail = Some(Box::new(node.clone())); | ++++++++ Some errors have detailed explanations: E0382, E0597. For more information about an error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "21": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 30: Char 33: error: borrow of moved value: `node1` (solution.rs) | 23 | (Some(node1), Some(node2)) => { | ----- move occurs because `node1` has type `Box<list_node::ListNode>`, which does not implement the `Copy` trait 24 | let mut head = if node1.val < node2.val { 25 | node1 | ----- value moved here ... 30 | let mut next1 = node1.next.clone(); | ^^^^^^^^^^ value borrowed here after move | help: consider cloning the value if the performance cost is acceptable | 25 | node1.clone() | ++++++++ Line 31: Char 33: error: borrow of moved value: `node2` (solution.rs) | 23 | (Some(node1), Some(node2)) => { | ----- move occurs because `node2` has type `Box<list_node::ListNode>`, which does not implement the `Copy` trait ... 27 | node2 | ----- value moved here ... 31 | let mut next2 = node2.next.clone(); | ^^^^^^^^^^ value borrowed here after move | help: consider cloning the value if the performance cost is acceptable | 27 | node2.clone() | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "138": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "92": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 30: Char 28: error: use of moved value: `node` (solution.rs) | 25 | while let Some(mut node) = head { | -------- | | | this reinitialization might get skipped | move occurs because `node` has type `Box<list_node::ListNode>`, which does not implement the `Copy` trait 26 | if count == left { 27 | start = Some(node); | ---- value moved here ... 30 | end = Some(node); | ^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 27 | start = Some(node.clone()); | ++++++++ Line 39: Char 24: error: use of moved value: `node.next` (solution.rs) | 25 | while let Some(mut node) = head { | -------- | | | this reinitialization might get skipped | move occurs because `node` has type `Box<list_node::ListNode>`, which does not implement the `Copy` trait 26 | if count == left { 27 | start = Some(node); | ---- value moved here ... 30 | end = Some(node); | ---- value moved here ... 39 | head = node.next; | ^^^^^^^^^ value used here after move For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "25": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 35: Char 27: error: mismatched types (solution.rs) | 31 | let mut current = node; | ---- expected due to this value ... 35 | current = next_node.unwrap(); | ^^^^^^^^^^^^^^^^^^ expected `&mut Box<ListNode>`, found `Box<ListNode>` | = note: expected mutable reference `&mut Box<list_node::ListNode>` found struct `Box<list_node::ListNode>` help: consider dereferencing here to assign to the mutably borrowed value | 35 | *current = next_node.unwrap(); | + Line 38: Char 25: error: mismatched types (solution.rs) | 38 | prev = Some(node); | ---- ^^^^ expected `Box<ListNode>`, found `&mut Box<ListNode>` | | | arguments to this enum variant are incorrect | = note: expected struct `Box<list_node::ListNode>` found mutable reference `&mut Box<list_node::ListNode>` Line 38: Char 20: help: the type constructed contains `&mut Box<list_node::ListNode>` due to the type of the argument passed (solution.rs) | 38 | prev = Some(node); | ^^^^^----^ | | | this argument influences the type of `Some` Line 570: Char 5: note: tuple variant defined here (solution.rs) For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "19": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 19: Char 25: error: failed to resolve: use of undeclared type `Rc` (solution.rs) | 19 | let mut dummy = Rc::new(RefCell::new(ListNode::new(0))); | ^^ use of undeclared type `Rc` | help: consider importing this struct | 42 + use std::rc::Rc; | Line 19: Char 33: error: failed to resolve: use of undeclared type `RefCell` (solution.rs) | 19 | let mut dummy = Rc::new(RefCell::new(ListNode::new(0))); | ^^^^^^^ use of undeclared type `RefCell` | help: consider importing one of these items | 42 + use core::cell::RefCell; | 42 + use std::cell::RefCell; | Line 24: Char 29: error: no method named `borrow` found for reference `&Box<list_node::ListNode>` in the current scope (solution.rs) | 24 | q = q.as_ref()?.borrow().next.as_ref(); | ^^^^^^ method not found in `&Box<ListNode>` | = help: items from traits can only be used if the trait is in scope help: the following trait is implemented but not in scope; perhaps add a `use` for it: | 18 + use std::borrow::Borrow; | Line 29: Char 29: error: no method named `borrow` found for reference `&Box<list_node::ListNode>` in the current scope (solution.rs) | 29 | q = q.as_ref()?.borrow().next.as_ref(); | ^^^^^^ method not found in `&Box<ListNode>` | = help: items from traits can only be used if the trait is in scope help: the following trait is implemented but not in scope; perhaps add a `use` for it: | 18 + use std::borrow::Borrow; | Some errors have detailed explanations: E0433, E0599. For more information about an error, try `rustc --explain E0433`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "82": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 28: Char 27: error: mismatched types (solution.rs) | 19 | let mut current = &mut head; | --------- expected due to this value ... 28 | current = next; | ^^^^ expected `&mut Option<Box<ListNode>>`, found `Option<Box<ListNode>>` | = note: expected mutable reference `&mut Option<Box<list_node::ListNode>>` found enum `Option<Box<list_node::ListNode>>` help: consider dereferencing here to assign to the mutably borrowed value | 28 | *current = next; | + Line 30: Char 29: error: mismatched types (solution.rs) | 30 | *previous = node.next.take(); | --------- ^^^^^^^^^^^^^^^^ expected `Option<&mut Box<ListNode>>`, found `Option<Box<ListNode>>` | | | expected due to the type of this binding | = note: expected enum `Option<&mut Box<list_node::ListNode>>` found enum `Option<Box<list_node::ListNode>>` Line 31: Char 27: error: mismatched types (solution.rs) | 19 | let mut current = &mut head; | --------- expected due to this value ... 27 | *previous = Some(node); | -------- here the type of `previous` is inferred to be `&mut Option<&mut Box<list_node::ListNode>>` ... 31 | current = previous; | ^^^^^^^^ expected `&mut Option<Box<ListNode>>`, found `&mut Option<&mut Box<ListNode>>` | = note: expected mutable reference `&mut Option<Box<list_node::ListNode>>` found mutable reference `&mut Option<&mut Box<list_node::ListNode>>` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "61": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 31: Char 27: error: use of moved value: `head` (solution.rs) | 18 | pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { | ---- move occurs because `head` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait 19 | let mut len = 0; 20 | let mut current = head; | ---- value moved here ... 31 | let mut current = head; | ^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 20 | let mut current = head.clone(); | ++++++++ Line 35: Char 23: error: borrow of moved value: `current` (solution.rs) | 31 | let mut current = head; | ----------- move occurs because `current` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait 32 | let mut prev = None; 33 | for _ in 0..len - k { | ------------------- inside of this loop 34 | prev = current; | ------- value moved here 35 | current = current.as_ref().unwrap().next; | ^^^^^^^ value borrowed here after move | help: consider cloning the value if the performance cost is acceptable | 34 | prev = current.clone(); | ++++++++ Line 35: Char 23: error: cannot move out of a shared reference (solution.rs) | 35 | current = current.as_ref().unwrap().next; | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait Line 39: Char 13: error: cannot assign to `prev.next`, as `prev` is not declared as mutable (solution.rs) | 39 | prev.next = head; | ^^^^^^^^^ cannot assign | help: consider changing this to be mutable | 38 | if let Some(mut prev) = prev { | +++ Line 39: Char 25: error: use of moved value: `head` (solution.rs) | 18 | pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { | ---- move occurs because `head` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait ... 31 | let mut current = head; | ---- value moved here ... 39 | prev.next = head; | ^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 31 | let mut current = head.clone(); | ++++++++ Line 43: Char 9: error: use of moved value: `head` (solution.rs) | 18 | pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> { | ---- move occurs because `head` has type `Option<Box<list_node::ListNode>>`, which does not implement the `Copy` trait ... 31 | let mut current = head; | ---- value moved here ... 39 | prev.next = head; | ---- value moved here ... 43 | head | ^^^^ value used here after move | help: consider cloning the value if the performance cost is acceptable | 39 | prev.next = head.clone(); | ++++++++ help: consider cloning the value if the performance cost is acceptable | 31 | let mut current = head.clone(); | ++++++++ Some errors have detailed explanations: E0382, E0507, E0594. For more information about an error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to 6 previous errors"}, "86": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 38: Char 14: error: mismatched types (solution.rs) | 38 | Some(less_than_x) | ---- ^^^^^^^^^^^ expected `Box<ListNode>`, found `ListNode` | | | arguments to this enum variant are incorrect | = note: expected struct `Box<list_node::ListNode>` found struct `list_node::ListNode` = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html Line 38: Char 9: help: the type constructed contains `list_node::ListNode` due to the type of the argument passed (solution.rs) | 38 | Some(less_than_x) | ^^^^^-----------^ | | | this argument influences the type of `Some` Line 570: Char 5: note: tuple variant defined here (solution.rs) help: store this in the heap by calling `Box::new` | 38 | Some(Box::new(less_than_x)) | +++++++++ + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "146": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 22: Char 27: error: use of unstable library feature 'linked_list_remove' (solution.rs) | 22 | self.list.remove(value); | ^^^^^^ | = note: see issue #69210 <https://github.com/rust-lang/rust/issues/69210> for more information Line 22: Char 34: error: mismatched types (solution.rs) | 22 | self.list.remove(value); | ------ ^^^^^ expected `usize`, found `&LinkedList<i32>` | | | arguments to this method are incorrect | = note: expected type `usize` found reference `&LinkedList<i32>` Line 1006: Char 12: note: method defined here (solution.rs) Line 24: Char 17: error: mismatched types (solution.rs) | 19 | fn get(&mut self, key: i32) -> i32 { | --- expected `i32` because of return type ... 24 | *value | ^^^^^^ expected `i32`, found `LinkedList<i32>` | = note: expected type `i32` found struct `LinkedList<i32>` Line 33: Char 27: error: use of unstable library feature 'linked_list_remove' (solution.rs) | 33 | self.list.remove(value); | ^^^^^^ | = note: see issue #69210 <https://github.com/rust-lang/rust/issues/69210> for more information Line 33: Char 34: error: mismatched types (solution.rs) | 33 | self.list.remove(value); | ------ ^^^^^ expected `usize`, found `&LinkedList<i32>` | | | arguments to this method are incorrect | = note: expected type `usize` found reference `&LinkedList<i32>` Line 1006: Char 12: note: method defined here (solution.rs) Line 35: Char 26: error: mismatched types (solution.rs) | 35 | *value = value; | ------ ^^^^^ expected `LinkedList<i32>`, found `&LinkedList<i32>` | | | expected due to the type of this binding | = note: expected struct `LinkedList<i32>` found reference `&LinkedList<i32>` help: consider using clone here | 35 | *value = value.clone(); | ++++++++ Line 43: Char 38: error: mismatched types (solution.rs) | 43 | self.map.insert(key, self.list.front_mut()); | ------ ^^^^^^^^^^^^^^^^^^^^^ expected `LinkedList<i32>`, found `Option<&mut i32>` | | | arguments to this method are incorrect | = note: expected struct `LinkedList<i32>` found enum `Option<&mut i32>` Line 43: Char 17: help: the return type of this call is `Option<&mut i32>` due to the type of the argument passed (solution.rs) | 43 | self.map.insert(key, self.list.front_mut()); | ^^^^^^^^^^^^^^^^^^^^^---------------------^ | | | this argument influences the return type of `insert` Line 1103: Char 12: note: method defined here (solution.rs) help: try removing the method call | 44 - self.map.insert(key, self.list.front_mut()); 44 + self.map.insert(key, self.list); | Some errors have detailed explanations: E0308, E0658. For more information about an error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 7 previous errors"}, "104": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "100": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "226": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 30: Char 27: error: the trait bound `Rc<RefCell<tree_node::TreeNode>>: From<RefMut<'_, tree_node::TreeNode>>` is not satisfied (solution.rs) | 30 | Some(node.into()) | ^^^^ the trait `From<RefMut<'_, tree_node::TreeNode>>` is not implemented for `Rc<RefCell<tree_node::TreeNode>>` | = help: the following other types implement trait `From<T>`: <Rc<OsStr> as From<OsString>> <Rc<OsStr> as From<&OsStr>> <Rc<Path> as From<PathBuf>> <Rc<Path> as From<&Path>> <Rc<CStr> as From<CString>> <Rc<CStr> as From<&CStr>> <Rc<str> as From<std::string::String>> <Rc<str> as From<&str>> and 7 others = note: required for `RefMut<'_, tree_node::TreeNode>` to implement `Into<Rc<RefCell<tree_node::TreeNode>>>` For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "101": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 33: Char 9: error: arguments to this function are incorrect (solution.rs) | 33 | is_symmetric_helper(root.as_deref(), root.as_deref()) | ^^^^^^^^^^^^^^^^^^^ | Line 33: Char 29: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 33 | is_symmetric_helper(root.as_deref(), root.as_deref()) | ^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 33: Char 46: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 33 | is_symmetric_helper(root.as_deref(), root.as_deref()) | ^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 23: Char 12: note: function defined here (solution.rs) | 23 | fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool { | ^^^^^^^^^^^^^^^^^^^ ----------------------- ------------------------ Line 27: Char 39: error: arguments to this function are incorrect (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^^ | Line 27: Char 59: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 27: Char 78: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 23: Char 12: note: function defined here (solution.rs) | 23 | fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool { | ^^^^^^^^^^^^^^^^^^^ ----------------------- ------------------------ Line 27: Char 101: error: arguments to this function are incorrect (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^^ | Line 27: Char 121: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ... l.val == r.val && is_symmetric_helper(l.left.as_deref(), r.right.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_d... | ^^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 27: Char 141: note: expected `Option<&TreeNode>`, found `Option<&RefCell<TreeNode>>` (solution.rs) | 27 | ...ht.as_deref()) && is_symmetric_helper(l.right.as_deref(), r.left.as_deref()) | ^^^^^^^^^^^^^^^^^ = note: expected enum `Option<&tree_node::TreeNode>` found enum `Option<&RefCell<tree_node::TreeNode>>` Line 23: Char 12: note: function defined here (solution.rs) | 23 | fn is_symmetric_helper(left: Option<&TreeNode>, right: Option<&TreeNode>) -> bool { | ^^^^^^^^^^^^^^^^^^^ ----------------------- ------------------------ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 3 previous errors"}, "105": {"compiled": "false", "verdict": "Context-Length Exceeded", "stderr": "Context-Length Exceeded"}, "106": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 38: Char 48: index out of bounds: the len is 5 but the index is 18446744073709551615 (solution.rs)"}, "117": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "114": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 28: Char 39: error: no field `right` on type `&Rc<RefCell<tree_node::TreeNode>>` (solution.rs) | 28 | if let Some(right) = node.right.take() { | ^^^^^ unknown field Line 29: Char 33: error: no field `left` on type `&Rc<RefCell<tree_node::TreeNode>>` (solution.rs) | 29 | stack.push(node.left.take()); | ^^^^ unknown field Line 30: Char 28: error: mismatched types (solution.rs) | 30 | stack.push(Some(right)); | ---- ^^^^^^^^^^^ expected `&mut Option<Rc<RefCell<TreeNode>>>`, found `Option<_>` | | | arguments to this method are incorrect | = note: expected mutable reference `&mut Option<Rc<RefCell<tree_node::TreeNode>>>` found enum `Option<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: consider mutably borrowing here | 30 | stack.push(&mut Some(right)); | ++++ Line 33: Char 44: error: no field `left` on type `&Rc<RefCell<tree_node::TreeNode>>` (solution.rs) | 33 | prev.right = Some(node.left.take()); | ^^^^ unknown field Some errors have detailed explanations: E0308, E0609. For more information about an error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "112": {"compiled": "false", "verdict": "Context-Length Exceeded", "stderr": "Context-Length Exceeded"}, "129": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "124": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "173": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 33: Char 23: error: borrow of moved value: `node` (solution.rs) | 31 | while let Some(node) = current { | ---- move occurs because `node` has type `Rc<RefCell<tree_node::TreeNode>>`, which does not implement the `Copy` trait 32 | stack.push(node); | ---- value moved here 33 | current = node.borrow().left.clone(); | ^^^^^^^^^^^^^ value borrowed here after move | = note: borrow occurs due to deref coercion to `RefCell<tree_node::TreeNode>` help: clone the value to increment its reference count | 32 | stack.push(node.clone()); | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "222": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "236": {"compiled": "false", "verdict": "Context-Length Exceeded", "stderr": "Context-Length Exceeded"}, "199": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "637": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 34: Char 32: error: borrow of moved value: `result` (solution.rs) | 24 | let mut result = Vec::new(); | ---------- move occurs because `result` has type `Vec<f64>`, which does not implement the `Copy` trait ... 34 | result.into_iter().map(|x| x as f64 / result.len() as f64).collect() | ----------- ^^^ ------ borrow occurs due to use in closure | | | | | value borrowed here after move | `result` moved due to this method call | Line 266: Char 18: note: `into_iter` takes ownership of the receiver `self`, which moves `result` (solution.rs) help: you can `clone` the value and consume it, but this might not be your desired behavior | 34 | result.clone().into_iter().map(|x| x as f64 / result.len() as f64).collect() | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "102": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 32: Char 32: error: mismatched types (solution.rs) | 25 | queue.push(root); | ----- ---- this argument has type `Option<Rc<RefCell<tree_node::TreeNode>>>`... | | | ... which causes `queue` to have type `Vec<Option<Rc<RefCell<tree_node::TreeNode>>>>` ... 32 | queue.push(left.clone()); | ---- ^^^^^^^^^^^^ expected `Option<Rc<RefCell<TreeNode>>>`, found `Rc<RefCell<TreeNode>>` | | | arguments to this method are incorrect | = note: expected enum `Option<Rc<_>>` found struct `Rc<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: try wrapping the expression in `Some` | 32 | queue.push(Some(left.clone())); | +++++ + Line 35: Char 32: error: mismatched types (solution.rs) | 25 | queue.push(root); | ----- ---- this argument has type `Option<Rc<RefCell<tree_node::TreeNode>>>`... | | | ... which causes `queue` to have type `Vec<Option<Rc<RefCell<tree_node::TreeNode>>>>` ... 35 | queue.push(right.clone()); | ---- ^^^^^^^^^^^^^ expected `Option<Rc<RefCell<TreeNode>>>`, found `Rc<RefCell<TreeNode>>` | | | arguments to this method are incorrect | = note: expected enum `Option<Rc<_>>` found struct `Rc<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: try wrapping the expression in `Some` | 35 | queue.push(Some(right.clone())); | +++++ + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "103": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 47: Char 36: error: mismatched types (solution.rs) | 28 | queue.push(root); | ----- ---- this argument has type `Option<Rc<RefCell<tree_node::TreeNode>>>`... | | | ... which causes `queue` to have type `Vec<Option<Rc<RefCell<tree_node::TreeNode>>>>` ... 47 | queue.push(left); | ---- ^^^^ expected `Option<Rc<RefCell<TreeNode>>>`, found `Rc<RefCell<TreeNode>>` | | | arguments to this method are incorrect | = note: expected enum `Option<Rc<_>>` found struct `Rc<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: try wrapping the expression in `Some` | 47 | queue.push(Some(left)); | +++++ + Line 51: Char 36: error: mismatched types (solution.rs) | 28 | queue.push(root); | ----- ---- this argument has type `Option<Rc<RefCell<tree_node::TreeNode>>>`... | | | ... which causes `queue` to have type `Vec<Option<Rc<RefCell<tree_node::TreeNode>>>>` ... 51 | queue.push(right); | ---- ^^^^^ expected `Option<Rc<RefCell<TreeNode>>>`, found `Rc<RefCell<TreeNode>>` | | | arguments to this method are incorrect | = note: expected enum `Option<Rc<_>>` found struct `Rc<_>` Line 1877: Char 12: note: method defined here (solution.rs) help: try wrapping the expression in `Some` | 51 | queue.push(Some(right)); | +++++ + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "530": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 24: Char 13: error: type annotations needed for `Option<T>` (solution.rs) | 24 | let mut prev = None; | ^^^^^^^^ ... 31 | let prev = prev.borrow(); | ---- type must be known at this point | help: consider giving `prev` an explicit type, where the placeholders `_` are specified | 24 | let mut prev: Option<T> = None; | +++++++++++ For more information about this error, try `rustc --explain E0282`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "230": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "98": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 24: Char 13: error: type annotations needed for `Option<T>` (solution.rs) | 24 | let mut prev = None; | ^^^^^^^^ ... 34 | if node.val <= prev_node.val { | --------- type must be known at this point | help: consider giving `prev` an explicit type, where the placeholders `_` are specified | 24 | let mut prev: Option<T> = None; | +++++++++++ For more information about this error, try `rustc --explain E0282`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "200": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 10: Char 26: error: cannot find function `dfs` in this scope (solution.rs) | 10 | count += dfs(&grid, i, j); | ^^^ not found in this scope | help: consider using the associated function on `Self` | 10 | count += Self::dfs(&grid, i, j); | ++++++ Line 28: Char 5: error: cannot find function `dfs` in this scope (solution.rs) | 28 | dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ^^^ not found in this scope | help: consider using the associated function on `Self` | 28 | Self::dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ++++++ Line 28: Char 27: error: cannot find function `dfs` in this scope (solution.rs) | 28 | dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ^^^ not found in this scope | help: consider using the associated function on `Self` | 28 | dfs(grid, i + 1, j) + Self::dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ++++++ Line 28: Char 49: error: cannot find function `dfs` in this scope (solution.rs) | 28 | dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ^^^ not found in this scope | help: consider using the associated function on `Self` | 28 | dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + Self::dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ++++++ Line 28: Char 71: error: cannot find function `dfs` in this scope (solution.rs) | 28 | dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1) | ^^^ not found in this scope | help: consider using the associated function on `Self` | 28 | dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + Self::dfs(grid, i, j - 1) | ++++++ For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 5 previous errors"}, "130": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "133": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "399": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 4: Char 13: error: mismatched types (solution.rs) | 4 | for (i, (a, b)) in equations.iter().enumerate() { | ^^^^^^ ---------------------------- this is an iterator with items of type `(usize, &Vec<std::string::String>)` | | | expected `Vec<String>`, found `(_, _)` | = note: expected struct `Vec<std::string::String>` found tuple `(_, _)` Line 10: Char 9: error: mismatched types (solution.rs) | 10 | for (a, b) in queries { | ^^^^^^ ------- this is an iterator with items of type `Vec<std::string::String>` | | | expected `Vec<String>`, found `(_, _)` | = note: expected struct `Vec<std::string::String>` found tuple `(_, _)` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "207": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "210": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 18: Char 48: error: mismatched types (solution.rs) | 18 | in_degree.insert(pre_course, in_degree[pre_course] + 1); | ^^^^^^^^^^ expected `&i32`, found `i32` | help: consider borrowing here | 18 | in_degree.insert(pre_course, in_degree[&pre_course] + 1); | + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "909": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 16: Char 20: error: mismatched types (solution.rs) | 5 | let mut curr = 1; | - expected due to this value ... 16 | curr = dest; | ^^^^ expected `usize`, found `i32` For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "433": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 26: Char 47: error: a value of type `Vec<char>` cannot be built from an iterator over elements of type `&char` (solution.rs) | 26 | if !visited[next.iter().collect::<Vec<char>>().iter().position(|&c| c == next[i]).unwrap()] { | ------- ^^^^^^^^^ value of type `Vec<char>` cannot be built from `std::iter::Iterator<Item=&char>` | | | required by a bound introduced by this call | = help: the trait `FromIterator<&char>` is not implemented for `Vec<char>` = help: the trait `FromIterator<T>` is implemented for `Vec<T>` Line 2048: Char 5: note: required by a bound in `collect` (solution.rs) Line 27: Char 47: error: a value of type `Vec<char>` cannot be built from an iterator over elements of type `&char` (solution.rs) | 27 | visited[next.iter().collect::<Vec<char>>().iter().position(|&c| c == next[i]).unwrap()] = true; | ------- ^^^^^^^^^ value of type `Vec<char>` cannot be built from `std::iter::Iterator<Item=&char>` | | | required by a bound introduced by this call | = help: the trait `FromIterator<&char>` is not implemented for `Vec<char>` = help: the trait `FromIterator<T>` is implemented for `Vec<T>` Line 2048: Char 5: note: required by a bound in `collect` (solution.rs) For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "127": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 30: Char 30: error: no method named `insert` found for type `i32` in the current scope (solution.rs) | 30 | distance.insert(neighbor, distance + 1); | ^^^^^^ method not found in `i32` For more information about this error, try `rustc --explain E0599`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "208": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 9: Char 24: error: the trait bound `Box<Trie>: Copy` is not satisfied (solution.rs) | 9 | children: [None; 26], | ^^^^ the trait `Copy` is not implemented for `Box<Trie>` | = note: required for `Option<Box<Trie>>` to implement `Copy` = note: the `Copy` trait is required because this value will be copied for each element of the array For more information about this error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "211": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "212": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "17": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 21: Char 32: error: use of moved value: `result` (solution.rs) | 3 | let mut result = Vec::new(); | ---------- move occurs because `result` has type `Vec<std::string::String>`, which does not implement the `Copy` trait ... 15 | for digit in digits.chars() { | --------------------------- inside of this loop ... 20 | for letter in letters { | --------------------- inside of this loop 21 | for combination in result { | ^^^^^^ `result` moved due to this implicit call to `.into_iter()`, in previous iteration of loop ... 26 | result = new_result; | ------ this reinitialization might get skipped | Line 266: Char 18: note: `into_iter` takes ownership of the receiver `self`, which moves `result` (solution.rs) help: consider iterating over a slice of the `Vec<std::string::String>`'s content to avoid moving into the `for` loop | 21 | for combination in &result { | + For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "77": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "46": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "39": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "52": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "22": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 22: Char 13: error: cannot find function `generate` in this scope (solution.rs) | 22 | generate(stack, result); | ^^^^^^^^ not found in this scope Line 25: Char 13: error: cannot find function `generate` in this scope (solution.rs) | 25 | generate(stack, result); | ^^^^^^^^ not found in this scope For more information about this error, try `rustc --explain E0425`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "79": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 13: Char 30: error: mismatched types (solution.rs) | 13 | if Self::dfs(board, i, j, &word_chars, 0, &mut visited) { | --------- ^^^^^ expected `&Vec<Vec<char>>`, found `Vec<Vec<char>>` | | | arguments to this function are incorrect | = note: expected reference `&Vec<Vec<char>>` found struct `Vec<Vec<char>>` Line 23: Char 4: note: associated function defined here (solution.rs) | 23 | fn dfs(board: &Vec<Vec<char>>, i: usize, j: usize, word: &Vec<char>, index: usize, visited: &mut Vec<Vec<bool>>) -> bool { | ^^^ ---------------------- help: consider borrowing here | 13 | if Self::dfs(&board, i, j, &word_chars, 0, &mut visited) { | + For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "108": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "148": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 33: Char 20: error: use of moved value: `curr` (solution.rs) | 23 | let mut curr = head.as_deref_mut(); | -------- move occurs because `curr` has type `Option<&mut list_node::ListNode>`, which does not implement the `Copy` trait ... 31 | while curr.is_some() { | -------------------- inside of this loop 32 | nodes.push(curr.unwrap().val); | ---- -------- `curr` moved due to this method call | | | help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents 33 | curr = curr.unwrap().next.as_deref_mut(); | ^^^^ value used here after move Line 48: Char 17: error: use of moved value: `curr` (solution.rs) | 39 | let mut curr = head.as_deref_mut(); | -------- move occurs because `curr` has type `Option<&mut list_node::ListNode>`, which does not implement the `Copy` trait 40 | for val in nodes { | ---------------- inside of this loop ... 47 | let next_ptr = curr.unwrap().next.as_deref_mut(); | ---- -------- `curr` moved due to this method call | | | help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents 48 | curr.unwrap().next = Some(new_node); | ^^^^ value used here after move | Line 931: Char 25: note: `Option::<T>::unwrap` takes ownership of the receiver `self`, which moves `curr` (solution.rs) For more information about this error, try `rustc --explain E0382`. error: could not compile `prog` (bin \"prog\") due to 2 previous errors"}, "427": {"compiled": "false", "verdict": "No Rust Compiler", "stderr": "No Rust Compiler"}, "23": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 24: Char 22: error: the trait bound `list_node::ListNode: Ord` is not satisfied (solution.rs) | 24 | heap.push(Reverse(node)); | ^^^^ the trait `Ord` is not implemented for `list_node::ListNode` | = help: the trait `Ord` is implemented for `Reverse<T>` = note: required for `Box<list_node::ListNode>` to implement `Ord` = note: 1 redundant requirement hidden = note: required for `Reverse<Box<list_node::ListNode>>` to implement `Ord` Line 607: Char 5: note: required by a bound in `BinaryHeap::<T, A>::push` (solution.rs) Line 21: Char 24: error: the trait bound `list_node::ListNode: Ord` is not satisfied (solution.rs) | 21 | let mut heap = BinaryHeap::new(); | ^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `list_node::ListNode` | = help: the trait `Ord` is implemented for `Reverse<T>` = note: required for `Box<list_node::ListNode>` to implement `Ord` = note: 1 redundant requirement hidden = note: required for `Reverse<Box<list_node::ListNode>>` to implement `Ord` Line 437: Char 5: note: required by a bound in `BinaryHeap::<T>::new` (solution.rs) Line 31: Char 46: error: the method `pop` exists for struct `BinaryHeap<Reverse<Box<ListNode>>>`, but its trait bounds were not satisfied (solution.rs) | 31 | while let Some(Reverse(node)) = heap.pop() { | ^^^ method cannot be called on `BinaryHeap<Reverse<Box<ListNode>>>` due to unsatisfied trait bounds --> /rustc/a28077b28a02b92985b3a3faecf92813155f1ea1/library/core/src/cmp.rs:610:1 | = note: doesn't satisfy `Reverse<Box<list_node::ListNode>>: Ord` | = note: doesn't satisfy `Reverse<Box<list_node::ListNode>>: PartialOrd` | = note: the following trait bounds were not satisfied: `Reverse<Box<list_node::ListNode>>: Ord` `Reverse<Box<list_node::ListNode>>: PartialOrd` which is required by `Reverse<Box<list_node::ListNode>>: Ord` Line 37: Char 22: error: the method `push` exists for struct `BinaryHeap<Reverse<Box<ListNode>>>`, but its trait bounds were not satisfied (solution.rs) | 37 | heap.push(Reverse(next)); | ^^^^ method cannot be called on `BinaryHeap<Reverse<Box<ListNode>>>` due to unsatisfied trait bounds --> /rustc/a28077b28a02b92985b3a3faecf92813155f1ea1/library/core/src/cmp.rs:610:1 | = note: doesn't satisfy `Reverse<Box<list_node::ListNode>>: Ord` | = note: doesn't satisfy `Reverse<Box<list_node::ListNode>>: PartialOrd` | = note: the following trait bounds were not satisfied: `Reverse<Box<list_node::ListNode>>: Ord` `Reverse<Box<list_node::ListNode>>: PartialOrd` which is required by `Reverse<Box<list_node::ListNode>>: Ord` Some errors have detailed explanations: E0277, E0599. For more information about an error, try `rustc --explain E0277`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "53": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "918": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "35": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "74": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 11: Char 18: index out of bounds: the len is 1 but the index is 9223372036854775807 (solution.rs)"}, "162": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 16: Char 5: error: mismatched types (solution.rs) | 2 | pub fn find_peak_element(nums: Vec<i32>) -> i32 { | --- expected `i32` because of return type ... 16 | left | ^^^^ expected `i32`, found `usize` | help: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit | 16 | left.try_into().unwrap() | ++++++++++++++++++++ For more information about this error, try `rustc --explain E0308`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "33": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 6: Char 19: index out of bounds: the len is 7 but the index is 9223372036854775807 (solution.rs)"}, "34": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 8: Char 19: index out of bounds: the len is 0 but the index is 9223372036854775807 (solution.rs)"}, "153": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "4": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "215": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "502": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 10: Char 24: index out of bounds: the len is 2 but the index is 2 (solution.rs)"}, "373": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "295": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "67": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 14: Char 48: index out of bounds: the len is 1 but the index is 18446744073709551615 (solution.rs)"}, "190": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 3: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` 3 | x = x.reverse_bits(); | ^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument Line 4: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` 3 | x = x.reverse_bits(); 4 | x >>= 1; | ^^^^^^^ cannot assign to immutable argument Line 5: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` ... 5 | x |= x >> 1; | ^^^^^^^^^^^ cannot assign to immutable argument Line 6: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` ... 6 | x |= x >> 2; | ^^^^^^^^^^^ cannot assign to immutable argument Line 7: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` ... 7 | x |= x >> 4; | ^^^^^^^^^^^ cannot assign to immutable argument Line 8: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` ... 8 | x |= x >> 8; | ^^^^^^^^^^^ cannot assign to immutable argument Line 9: Char 5: error: cannot assign to immutable argument `x` (solution.rs) | 2 | pub fn reverse_bits(x: u32) -> u32 { | - help: consider making this binding mutable: `mut x` ... 9 | x |= x >> 16; | ^^^^^^^^^^^^ cannot assign to immutable argument For more information about this error, try `rustc --explain E0384`. error: could not compile `prog` (bin \"prog\") due to 7 previous errors"}, "191": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "136": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "137": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "201": {"compiled": "true", "verdict": "Time Limit Exceeded", "stderr": "Time Limit Exceeded"}, "9": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "66": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 2: Char 21: error: cannot borrow `digits` as mutable, as it is not declared as mutable (solution.rs) | 2 | pub fn plus_one(digits: Vec<i32>) -> Vec<i32> { | ^^^^^^ not mutable 3 | let mut carry = 1; 4 | for digit in digits.iter_mut().rev() { | ------ cannot borrow as mutable ... 13 | digits.insert(0, carry); | ------ cannot borrow as mutable | help: consider changing this to be mutable | 2 | pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> { | +++ For more information about this error, try `rustc --explain E0596`. error: could not compile `prog` (bin \"prog\") due to previous error"}, "172": {"compiled": "true", "verdict": "Time Limit Exceeded", "stderr": "Time Limit Exceeded"}, "69": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "50": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "149": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "70": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "198": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "139": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 10: Char 51: byte index 18446744073709551615 is out of bounds of `leetcode` (solution.rs)"}, "322": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "300": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "120": {"compiled": "true", "verdict": "Runtime Error", "stderr": "Line 6: Char 33: index out of bounds: the len is 4 but the index is 4 (solution.rs)"}, "64": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "63": {"compiled": "true", "verdict": "Accepted", "stderr": "Accepted"}, "5": {"compiled": "false", "verdict": "Compilation Error", "stderr": "Line 15: Char 13: error: cannot assign twice to immutable variable `left` (solution.rs) | 10 | let (left, right) = (i, i); | ---- | | | first assignment to `left` | help: consider making this binding mutable: `mut left` ... 15 | left -= 1; | ^^^^^^^^^ cannot assign twice to immutable variable Line 16: Char 13: error: cannot assign twice to immutable variable `right` (solution.rs) | 10 | let (left, right) = (i, i); | ----- | | | first assignment to `right` | help: consider making this binding mutable: `mut right` ... 16 | right += 1; | ^^^^^^^^^^ cannot assign twice to immutable variable Line 24: Char 13: error: cannot assign twice to immutable variable `left` (solution.rs) | 19 | let (left, right) = (i, i + 1); | ---- | | | first assignment to `left` | help: consider making this binding mutable: `mut left` ... 24 | left -= 1; | ^^^^^^^^^ cannot assign twice to immutable variable Line 25: Char 13: error: cannot assign twice to immutable variable `right` (solution.rs) | 19 | let (left, right) = (i, i + 1); | ----- | | | first assignment to `right` | help: consider making this binding mutable: `mut right` ... 25 | right += 1; | ^^^^^^^^^^ cannot assign twice to immutable variable For more information about this error, try `rustc --explain E0384`. error: could not compile `prog` (bin \"prog\") due to 4 previous errors"}, "97": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "72": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "123": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "188": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}, "221": {"compiled": "true", "verdict": "Wrong Answer", "stderr": "Wrong Answer"}}